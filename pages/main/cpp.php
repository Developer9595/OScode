<!DOCTYPE html>
<html dir="ltr" lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- Tell the browser to be responsive to screen width -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <!-- Favicon icon -->
    <link rel="icon" type="image/png" sizes="16x16" href="../../assets/images/logo.png">
    <title>Личный кабинет</title>
    <!-- Custom CSS -->
    <link href="../../assets/extra-libs/c3/c3.min.css" rel="stylesheet">
    <link href="../../assets/libs/chartist/dist/chartist.min.css" rel="stylesheet">
    <link href="../../assets/extra-libs/jvector/jquery-jvectormap-2.0.2.css" rel="stylesheet" />
    <!-- Custom CSS -->
    <link href="../../dist/css/style.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>
    <!-- ============================================================== -->
    <!-- Preloader - style you can find in spinners.css -->
    <!-- ============================================================== -->
    <div class="preloader">
        <div class="lds-ripple">
            <div class="lds-pos"></div>
            <div class="lds-pos"></div>
        </div>
    </div>
    <!-- ============================================================== -->
    <!-- Main wrapper - style you can find in pages.scss -->
    <!-- ============================================================== -->
    <div id="main-wrapper" data-theme="light" data-layout="vertical" data-navbarbg="skin6" data-sidebartype="full"
        data-sidebar-position="fixed" data-header-position="fixed" data-boxed-layout="full">
        <!-- ============================================================== -->
        <!-- Topbar header - style you can find in pages.scss -->
        <!-- ============================================================== -->
        <header class="topbar" data-navbarbg="skin6">
            <nav class="navbar top-navbar navbar-expand-md">
                <div class="navbar-header" data-logobg="skin6">
                    <!-- This is for the sidebar toggle which is visible on mobile only -->
                    <a class="nav-toggler waves-effect waves-light d-block d-md-none" href="javascript:void(0)"><i
                            class="ti-menu ti-close"></i></a>
                    <!-- ============================================================== -->
                    <!-- Logo -->
                    <!-- ============================================================== -->
                    <div class="navbar-brand">
                        <!-- Logo icon -->
                        <a href="/">
                            <b class="logo-icon">
                                <!-- Dark Logo icon -->
                                <img src="../../assets/images/logo.png" width="128px" alt="LOGO" class="dark-logo" />
                                <!-- Light Logo icon -->
                                <img src="../../assets/images/logo.png" width="128px" alt="LOGO" class="light-logo" />
                            </b>
                        </a>
                    </div>
                    <!-- ============================================================== -->
                    <!-- End Logo -->
                    <!-- ============================================================== -->
                    <!-- ============================================================== -->
                    <!-- Toggle which is visible on mobile only -->
                    <!-- ============================================================== -->
                    <a class="topbartoggler d-block d-md-none waves-effect waves-light" href="javascript:void(0)"
                        data-toggle="collapse" data-target="#navbarSupportedContent"
                        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><i
                            class="ti-more"></i></a>
                </div>
                <!-- ============================================================== -->
                <!-- End Logo -->
                <!-- ============================================================== -->
                <div class="navbar-collapse collapse" id="navbarSupportedContent">
                    <!-- ============================================================== -->
                    <!-- toggle and nav items -->
                    <!-- ============================================================== -->
                    <ul class="navbar-nav float-left mr-auto ml-3 pl-1">
                        <!-- Notification -->
                        
                        <!-- End Notification -->
                        <!-- ============================================================== -->
                        <!-- create new -->
                        <!-- ============================================================== -->
                        <h3>Язык программирования C++</h3>
                        
                    </ul>
                    <!-- ============================================================== -->
                    <!-- Right side toggle and nav items -->
                    <!-- ============================================================== -->
                    
                    <ul class="navbar-nav float-right">
                        <!-- ============================================================== -->
                        <!-- Search -->
                        <!-- ============================================================== -->
                        
                        <!-- ============================================================== -->
                        <!-- User profile and search -->
                        <!-- ============================================================== -->
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" class="js-logout" href="javascript:void(0)" data-toggle="dropdown"
                                aria-haspopup="true" aria-expanded="false">
                                                                     
                                    <li class="header-menu__list-text">
                                    <div class="dropdown">
                                    <a class="btn btn- dropdown-toggle" href="#" role="button" id="dropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                   
                                    </a>
                                    <div class="dropdown-menu btn-username" aria-labelledby="dropdownMenuLink">
                                        <a class="dropdown-item" href="index.php">Главная страница</a>
                                        <a class="dropdown-item" id="somewhere" href="logout.php">Выход</a>
                                    </div>
                                    </div>
                                    </li>
                                </li>
                        <!-- ============================================================== -->
                    </ul>
                </div>
            </nav>
        </header>
        <!-- ============================================================== -->
        <!-- End Topbar header -->
        <!-- ============================================================== -->
        <!-- ============================================================== -->
        <!-- Left Sidebar - style you can find in sidebar.scss  -->
        <!-- ============================================================== -->
        <aside class="left-sidebar" data-sidebarbg="skin6">
            <!-- Sidebar scroll-->
            <div class="scroll-sidebar" data-sidebarbg="skin6">
                <!-- Sidebar navigation-->
                <nav class="sidebar-nav">
                    <ul id="sidebarnav">
                    
                        <li class="list-divider"></li>
                        <li class="nav-small-cap"><span class="hide-menu"></span></li>

                        <div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="ru" dir="ltr"><h2 id="mw-toc-heading">Меню</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#История"><span class="tocnumber">1</span> <span class="toctext">История</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Создание"><span class="tocnumber">1.1</span> <span class="toctext">Создание</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Развитие_и_стандартизация_языка"><span class="tocnumber">1.2</span> <span class="toctext">Развитие и стандартизация языка</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#История_названия"><span class="tocnumber">1.3</span> <span class="toctext">История названия</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Философия_C++"><span class="tocnumber">1.4</span> <span class="toctext">Философия C++</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Обзор_языка"><span class="tocnumber">2</span> <span class="toctext">Обзор языка</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#Типы"><span class="tocnumber">2.1</span> <span class="toctext">Типы</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Наследование"><span class="tocnumber">2.2</span> <span class="toctext">Наследование</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Полиморфизм"><span class="tocnumber">2.3</span> <span class="toctext">Полиморфизм</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Инкапсуляция"><span class="tocnumber">2.4</span> <span class="toctext">Инкапсуляция</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="#Друзья"><span class="tocnumber">2.4.1</span> <span class="toctext">Друзья</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Специальные_функции"><span class="tocnumber">2.5</span> <span class="toctext">Специальные функции</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Шаблоны"><span class="tocnumber">2.6</span> <span class="toctext">Шаблоны</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Стандартная_библиотека"><span class="tocnumber">3</span> <span class="toctext">Стандартная библиотека</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Общая_структура"><span class="tocnumber">3.1</span> <span class="toctext">Общая структура</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Состав"><span class="tocnumber">3.2</span> <span class="toctext">Состав</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Реализации"><span class="tocnumber">3.3</span> <span class="toctext">Реализации</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18"><a href="#Отличия_от_языка_C"><span class="tocnumber">4</span> <span class="toctext">Отличия от языка C</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#Совместимость_с_языком_С"><span class="tocnumber">4.1</span> <span class="toctext">Совместимость с языком С</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Новые_возможности"><span class="tocnumber">4.2</span> <span class="toctext">Новые возможности</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#C++_не_включает_в_себя_C"><span class="tocnumber">4.3</span> <span class="toctext">C++ не включает в себя C</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Средства_C,_которых_рекомендуется_избегать"><span class="tocnumber">4.4</span> <span class="toctext">Средства C, которых рекомендуется избегать</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="#Дальнейшее_развитие"><span class="tocnumber">5</span> <span class="toctext">Дальнейшее развитие</span></a>
<ul>
<li class="toclevel-2 tocsection-24"><a href="#Общие_направления_развития_C++"><span class="tocnumber">5.1</span> <span class="toctext">Общие направления развития C++</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Стандарт_C++11:_дополнения_в_ядре_языка"><span class="tocnumber">5.2</span> <span class="toctext">Стандарт C++11: дополнения в ядре языка</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="#Примеры_программ"><span class="tocnumber">6</span> <span class="toctext">Примеры программ</span></a>
<ul>
<li class="toclevel-2 tocsection-27"><a href="#Пример_№_1"><span class="tocnumber">6.1</span> <span class="toctext">Пример №&#160;1</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Пример_№_2"><span class="tocnumber">6.2</span> <span class="toctext">Пример №&#160;2</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="#Достоинства_и_недостатки"><span class="tocnumber">7</span> <span class="toctext">Достоинства и недостатки</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="#Достоинства"><span class="tocnumber">7.1</span> <span class="toctext">Достоинства</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Недостатки"><span class="tocnumber">7.2</span> <span class="toctext">Недостатки</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="#Критика"><span class="tocnumber">8</span> <span class="toctext">Критика</span></a>
<ul>
<li class="toclevel-2 tocsection-33"><a href="#О_критике_C++_в_целом"><span class="tocnumber">8.1</span> <span class="toctext">О критике C++ в целом</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Сравнение_с_альтернативными_языками"><span class="tocnumber">8.2</span> <span class="toctext">Сравнение с альтернативными языками</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="#C++_и_Ада"><span class="tocnumber">8.2.1</span> <span class="toctext">C++ и Ада</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#C++_и_Java"><span class="tocnumber">8.2.2</span> <span class="toctext">C++ и Java</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#C++_и_C"><span class="tocnumber">8.2.3</span> <span class="toctext">C++ и C</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#C++_и_функциональные_и_скриптовые_языки"><span class="tocnumber">8.2.4</span> <span class="toctext">C++ и функциональные и скриптовые языки</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-39"><a href="#Критика_отдельных_элементов_и_концепций"><span class="tocnumber">8.3</span> <span class="toctext">Критика отдельных элементов и концепций</span></a>
<ul>
<li class="toclevel-3 tocsection-40"><a href="#Контроль_за_поведением"><span class="tocnumber">8.3.1</span> <span class="toctext">Контроль за поведением</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="#Компонентное_и_объектно-ориентированное_программирование"><span class="tocnumber">8.3.2</span> <span class="toctext">Компонентное и объектно-ориентированное программирование</span></a></li>
<li class="toclevel-3 tocsection-42"><a href="#Метапрограммирование"><span class="tocnumber">8.3.3</span> <span class="toctext">Метапрограммирование</span></a></li>
<li class="toclevel-3 tocsection-43"><a href="#Кроссплатформенность"><span class="tocnumber">8.3.4</span> <span class="toctext">Кроссплатформенность</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-44"><a href="#Отсутствие_возможностей"><span class="tocnumber">8.4</span> <span class="toctext">Отсутствие возможностей</span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#Избыточные_и_опасные_возможности"><span class="tocnumber">8.5</span> <span class="toctext">Избыточные и опасные возможности</span></a>
<ul>
<li class="toclevel-3 tocsection-46"><a href="#Встроенные_средства_обхода_ограничений"><span class="tocnumber">8.5.1</span> <span class="toctext">Встроенные средства обхода ограничений</span></a></li>
<li class="toclevel-3 tocsection-47"><a href="#Неконтролируемая_макроподстановка"><span class="tocnumber">8.5.2</span> <span class="toctext">Неконтролируемая макроподстановка</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="#Проблемы_перегрузки"><span class="tocnumber">8.5.3</span> <span class="toctext">Проблемы перегрузки</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-49"><a href="#Вычислительная_эффективность"><span class="tocnumber">8.6</span> <span class="toctext">Вычислительная эффективность</span></a>
<ul>
<li class="toclevel-3 tocsection-50"><a href="#Результирующий_объём_исполнимого_кода"><span class="tocnumber">8.6.1</span> <span class="toctext">Результирующий объём исполнимого кода</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="#Потенциал_оптимизации"><span class="tocnumber">8.6.2</span> <span class="toctext">Потенциал оптимизации</span></a></li>
<li class="toclevel-3 tocsection-52"><a href="#Эффективное_управление_памятью"><span class="tocnumber">8.6.3</span> <span class="toctext">Эффективное управление памятью</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-53"><a href="#Результативность"><span class="tocnumber">8.7</span> <span class="toctext">Результативность</span></a>
<ul>
<li class="toclevel-3 tocsection-54"><a href="#Качество_и_культура_программирования"><span class="tocnumber">8.7.1</span> <span class="toctext">Качество и культура программирования</span></a></li>
<li class="toclevel-3 tocsection-55"><a href="#Исправление_исправного"><span class="tocnumber">8.7.2</span> <span class="toctext">Исправление исправного</span></a></li>
<li class="toclevel-3 tocsection-56"><a href="#Сложность_ради_самой_сложности"><span class="tocnumber">8.7.3</span> <span class="toctext">Сложность ради самой сложности</span></a></li>
<li class="toclevel-3 tocsection-57"><a href="#Саботаж"><span class="tocnumber">8.7.4</span> <span class="toctext">Саботаж</span></a></li>
<li class="toclevel-3 tocsection-58"><a href="#Ненадёжность_продукта"><span class="tocnumber">8.7.5</span> <span class="toctext">Ненадёжность продукта</span></a></li>
<li class="toclevel-3 tocsection-59"><a href="#Менеджмент_проектов"><span class="tocnumber">8.7.6</span> <span class="toctext">Менеджмент проектов</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-60"><a href="#Влияние_и_альтернативы"><span class="tocnumber">9</span> <span class="toctext">Влияние и альтернативы</span></a></li>
<li class="toclevel-1 tocsection-61"><a href="#См._также"><span class="tocnumber">10</span> <span class="toctext">См. также</span></a></li>
<li class="toclevel-1 tocsection-62"><a href="#Примечания"><span class="tocnumber">11</span> <span class="toctext">Примечания</span></a></li>
<li class="toclevel-1 tocsection-63"><a href="#Литература"><span class="tocnumber">12</span> <span class="toctext">Литература</span></a></li>
<li class="toclevel-1 tocsection-64"><a href="#Ссылки"><span class="tocnumber">13</span> <span class="toctext">Ссылки</span></a></li>
</ul>
</div>
                        
                            <ul aria-expanded="false" class="collapse first-level base-level-line">
                                
                                
                                
                                    <ul aria-expanded="false" class="collapse second-level base-level-line">
                                        
                                    </ul>
                                </li>
                                
                            </ul>
                        </li>
                        <li class="list-divider"></li>
                                    <script>
                                        (function(){
                                            var linkk = document.getElementById('somewhere');
                                            linkk.onclick = function goSomeWhere(){
                                                var val = confirm("Вы уверены что хотите выйти?");
                                                if(val == true){
                                                    window.location.href = "logout.php";
                                                }
                                                else{
                                                    return false;
                                                }
                                            }
                                            })();
                                    </script>
                    </ul>
                </nav>
                <!-- End Sidebar navigation -->
            </div>
            <!-- End Sidebar scroll-->
        </aside>
        <!-- ============================================================== -->
        <!-- End Left Sidebar - style you can find in sidebar.scss  -->
        <!-- ============================================================== -->
        <!-- ============================================================== -->
        <!-- Page wrapper  -->
        <!-- ============================================================== -->
        <div class="page-wrapper">
            <!-- ============================================================== -->
            <!-- Bread crumb and right sidebar toggle -->
            <!-- ============================================================== -->
            
            <!-- ============================================================== -->
            <!-- End Bread crumb and right sidebar toggle -->
            <!-- ============================================================== -->
            <!-- ============================================================== -->
            <!-- Container fluid  -->
            <!-- ============================================================== -->
            <div class="container-fluid">
                <!-- *************************************************************** -->
                <!-- Start First Cards -->
                <!-- *************************************************************** -->
                <div id="bodyContent" class="mw-body-content">
		
<table class="infobox" style="" data-name="Язык программирования"><tbody><tr><th colspan="2" class="infobox-above" style="background:#cfe3ff;">C++</th></tr><tr><td colspan="2" class="infobox-image" style=""> <span class="wikidata-claim" data-wikidata-property-id="P154" data-wikidata-claim-id="Q2407$125d3505-403d-b344-2dd6-30ba225d4699"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:ISO_C%2B%2B_Logo.svg" class="image"><img alt="ISO C++ Logo.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/71px-ISO_C%2B%2B_Logo.svg.png" decoding="async" width="71" height="80" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/107px-ISO_C%2B%2B_Logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/142px-ISO_C%2B%2B_Logo.svg.png 2x" data-file-width="306" data-file-height="344" /></a></span></span> </td></tr>
<tr>
<th class="plainlist">Семантика</th>
<td class="plainlist">
<a href="/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Мультипарадигмальный язык программирования">мультипарадигмальный</a>: <a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Объектно-ориентированное программирование">объектно-ориентированное</a>, <a href="/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Обобщённое программирование">обобщённое</a>, <a href="/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Процедурное программирование">процедурное</a>, <a href="/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Метапрограммирование">метапрограммирование</a></td>
</tr>
<tr>
<th class="plainlist">Класс языка</th>
<td class="plainlist">
<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$9d1e55ed-45fb-56fc-26ee-056c8f8e1dfe"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Объектно-ориентированный язык программирования">объектно-ориентированный язык программирования</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$69589060-4530-7499-359c-954d2b37b9f1"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Мультипарадигмальный язык программирования">мультипарадигмальный язык программирования</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$4e39be80-41ac-e433-2d42-22727629df05"><span class="wikidata-snak wikidata-main-snak"><span class="iw" data-title="процедурный язык программирования">процедурный язык программирования<sup class="plainlinks noprint"><a class="external text" href="https://www.wikidata.org/wiki/Q28922885?uselang=ru">[d&#x5d;</a></sup></span></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$dfa137b6-40a7-b43c-cd4b-8c07eb66b8bb"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" class="mw-redirect" title="Язык функционального программирования">язык функционального программирования</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$29e7c8c9-4ec4-e6ab-bd78-e46cf15f0a8c"><span class="wikidata-snak wikidata-main-snak"><span class="iw" data-title="язык обобщённого программирования">язык обобщённого программирования<sup class="plainlinks noprint"><a class="external text" href="https://www.wikidata.org/wiki/Q28923026?uselang=ru">[d&#x5d;</a></sup></span></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$eaef0cb8-4889-bb84-5841-5de486311e78"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Язык программирования">язык программирования</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$7d58bb80-4364-40e4-320a-722f6d66dfcc"><span class="wikidata-snak wikidata-main-snak"><span class="plainlinks"><a class="external text" href="https://ru.wikipedia.org/w/index.php?title=Free-form+language&amp;action=edit&amp;editintro=T:Нет_статьи/editintro&amp;preload=T:Нет_статьи/preload&amp;preloadparams%5B%5D=Q5499621&amp;preloadparams%5B%5D=Free-form+language&amp;preloadparams%5B%5D=Универсальная_карточка"><span style="color: #ba0000; text-decoration: inherit; -moz-text-decoration-color: #ba0000; text-decoration-color: #ba0000;">free-form language</span></a></span><sup><a href="https://www.wikidata.org/wiki/Q5499621" class="extiw" title="d:Q5499621">[d]</a></sup></span></span>&#32;и&#32;<span class="wikidata-claim" data-wikidata-property-id="P31" data-wikidata-claim-id="Q2407$21fca48d-4fee-406e-424f-29325d7d7bb0"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Компилируемый язык программирования">компилируемый язык программирования</a></span></span></td>
</tr>
<tr>
<th class="plainlist">Тип исполнения</th>
<td class="plainlist">
<a href="/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Компилируемый язык программирования">компилируемый</a></td>
</tr>
<tr>
<th class="plainlist">Появился в</th>
<td class="plainlist">
<span class="wikidata-claim" data-wikidata-property-id="P571" data-wikidata-claim-id="Q2407$ea2c2ed8-4e92-1852-3613-c8fbd32efe77"><span class="wikidata-snak wikidata-main-snak"><span class="nowrap"><a href="/wiki/1983_%D0%B3%D0%BE%D0%B4" title="1983 год">1983</a></span></span></span></td>
</tr>
<tr>
<th class="plainlist">Автор</th>
<td class="plainlist">
<span class="wikidata-claim" data-wikidata-property-id="P287" data-wikidata-claim-id="Q2407$6005334C-A1E7-4A59-9E25-A31D1DEBEC65"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%83%D1%81%D1%82%D1%80%D1%83%D0%BF,_%D0%91%D1%8C%D1%91%D1%80%D0%BD" title="Страуструп, Бьёрн">Страуструп, Бьёрн</a></span></span></td>
</tr>
<tr>
<th class="plainlist"><a href="/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D0%BC%D0%B5%D0%BD%D0%B8_%D1%84%D0%B0%D0%B9%D0%BB%D0%B0" title="Расширение имени файла">Расширение</a> файлов</th>
<td class="plainlist">
<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$a04b9c46-4cd3-2e69-ee01-82511a0d9e43"><span class="wikidata-snak wikidata-main-snak"><code>.cc</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$544d8569-4c34-aa3c-5b2f-c54642f2b2b3"><span class="wikidata-snak wikidata-main-snak"><code>.cpp</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$e97fe929-4f8a-abc5-fdf8-32dc902ce2da"><span class="wikidata-snak wikidata-main-snak"><code>.cxx</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$25590dcc-4d8b-9ace-067a-756438b2fa2d"><span class="wikidata-snak wikidata-main-snak"><code>.c</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$adab58c2-49fe-b3ed-1464-a80fdc5ec079"><span class="wikidata-snak wikidata-main-snak"><code>.c++</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$029ee1ef-4e54-5ea7-6e35-8f790a93eeb4"><span class="wikidata-snak wikidata-main-snak"><code>.h</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$7c79f37a-439e-3911-6698-1781cb7c8489"><span class="wikidata-snak wikidata-main-snak"><code>.hpp</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$e454062d-411b-7910-5400-f5c1bc8c8991"><span class="wikidata-snak wikidata-main-snak"><code>.hh</code></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$712288e0-41c6-97b5-b681-182dd6f007ad"><span class="wikidata-snak wikidata-main-snak"><code>.hxx</code></span></span> или <span class="wikidata-claim" data-wikidata-property-id="P1195" data-wikidata-claim-id="Q2407$a00eb6f1-454f-3953-d522-3fddb92ae0b8"><span class="wikidata-snak wikidata-main-snak"><code>.h++</code></span></span></td>
</tr>
<tr>
<th class="plainlist"><a href="/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" title="Система типов">Система типов</a></th>
<td class="plainlist">
<a href="/wiki/%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" title="Статическая типизация">статическая</a></td>
</tr>
<tr>
<th class="plainlist">Основные реализации</th>
<td class="plainlist">
<a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GNU C++</a>, <a href="/wiki/Microsoft_Visual_C%2B%2B" title="Microsoft Visual C++">Microsoft Visual C++</a>, <a href="/wiki/Intel_C%2B%2B_compiler" title="Intel C++ compiler">Intel C++ compiler</a>, <a href="/wiki/Open64" title="Open64">Open64 C++ Compiler</a>, <a href="/wiki/Clang" title="Clang">Clang</a>, <span class="iw plainlinks" data-title="Comeau C/C++" data-lang="en" data-lang-name="англ."><a href="/w/index.php?title=Comeau_C/C%2B%2B&amp;action=edit&amp;redlink=1" class="new" title="Comeau C/C++ (страница отсутствует)">Comeau C/C++</a><sup class="iw&#95;_note noprint" style="font-style:normal; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Comeau_C/C%2B%2B" class="extiw" title="en:Comeau C/C++"><span class="iw&#95;_tooltip" title="Версия статьи «Comeau C/C++» на английском языке">[en]</span></a></sup></span>, <a href="/wiki/C%2B%2B_Builder" title="C++ Builder">Embarcadero C++ Builder</a>, <a href="/wiki/Open_Watcom" title="Open Watcom">Watcom C++ compiler</a>, <a href="/wiki/Digital_Mars" title="Digital Mars">Digital Mars</a> C++, <a href="/wiki/Oracle_Solaris_Studio" title="Oracle Solaris Studio">Oracle Solaris Studio</a> C++ compiler, Turbo C++</td>
</tr>
<tr>
<th class="plainlist">Диалекты</th>
<td class="plainlist">
ISO/IEC 14882 C++</td>
</tr>
<tr>
<th class="plainlist">Испытал влияние</th>
<td class="plainlist">
<span class="wikidata-claim" data-wikidata-property-id="P737" data-wikidata-claim-id="Q2407$3be074e2-4f65-cb17-7d7c-8a695b638a5f"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">Си</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P737" data-wikidata-claim-id="Q2407$fd3e61b2-4a90-0b8b-1bce-ae467a46ef1d"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0" title="Симула">Симула</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P737" data-wikidata-claim-id="Q2407$b1b31971-42c5-a155-c093-e9ae029f5867"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D0%BB_68" title="Алгол 68">Алгол 68</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P737" data-wikidata-claim-id="Q2407$e3e9332c-4d73-227c-b0fe-8bdbec54fed2"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%9A%D0%BB%D1%83" title="Клу">Клу</a></span></span>,&#32;<span class="wikidata-claim" data-wikidata-property-id="P737" data-wikidata-claim-id="Q2407$98c9c678-4a61-dac7-44b4-313423dca814"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/ML" title="ML">ML</a></span></span>&#32;и&#32;<span class="wikidata-claim" data-wikidata-property-id="P737" data-wikidata-claim-id="Q2407$63BAB023-6399-49FC-8D3D-AC188596F91F"><span class="wikidata-snak wikidata-main-snak"><a href="/wiki/%D0%90%D0%B4%D0%B0_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Ада (язык программирования)">Ада</a></span></span></td>
</tr>
<tr>
<th class="plainlist">Сайт</th>
<td class="plainlist">
<span class="wikidata-claim" data-wikidata-property-id="P856" data-wikidata-claim-id="Q2407$0dca5a16-4402-2c8c-c6f1-44bc66b4e95e"><span class="wikidata-snak wikidata-main-snak"><a rel="nofollow" class="external text" href="https://isocpp.org/">isocpp.org</a>&#8203;&#160;<span class="ref-info" style="cursor:help;" title="на английском языке">(англ.)</span></span></span></td>
</tr><tr><td colspan="2" class="infobox-below" style="background:#dcebff;;"><span class="wikidata-claim" data-wikidata-property-id="P373" data-wikidata-claim-id="q2407$50462790-C060-433F-809C-4169980F9427"><span class="wikidata-snak wikidata-main-snak"><a href="https://commons.wikimedia.org/wiki/Category:C%2B%2B" title="commons:Category:C++"><img alt="Commons-logo.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Commons-logo.svg/15px-Commons-logo.svg.png" decoding="async" width="15" height="20" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Commons-logo.svg/23px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Commons-logo.svg/30px-Commons-logo.svg.png 2x" data-file-width="1024" data-file-height="1376" /></a>&#160;<a href="https://commons.wikimedia.org/wiki/Category:C%2B%2B" class="extiw" title="commons:Category:C++">Медиафайлы на Викискладе</a></span></span></td></tr>
</tbody></table>
<p><b><style data-mw-deduplicate="TemplateStyles:r104610285">.mw-parser-output .ts-comment-commentedText{border-bottom:1px dotted;cursor:help}@media(hover:none){.mw-parser-output .ts-comment-commentedText:not(.rt-commentedText){border-bottom:0;cursor:auto}}</style><span class="ts-comment-commentedText" title="Латинский алфавит">C</span>++</b> (читается <i>си-плюс-плюс</i><sup id="cite_ref-1" class="reference"><a href="#cite_note-1">&#91;1&#93;</a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2">&#91;2&#93;</a></sup>)&#160;— <a href="/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Компилируемый язык программирования">компилируемый</a>, <a href="/wiki/%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" title="Статическая типизация">статически типизированный</a> <a href="/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Язык программирования">язык программирования</a> общего назначения.
</p><p>Поддерживает такие <a href="/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" class="mw-redirect" title="Парадигмы программирования">парадигмы программирования</a>, как <a href="/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Процедурное программирование">процедурное программирование</a>, <a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Объектно-ориентированное программирование">объектно-ориентированное программирование</a>, <a href="/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Обобщённое программирование">обобщённое программирование</a>. Язык имеет богатую стандартную библиотеку, которая включает в себя распространённые контейнеры и алгоритмы, ввод-вывод, регулярные выражения, поддержку многопоточности и другие возможности. C++ сочетает свойства как <a href="/wiki/%D0%92%D1%8B%D1%81%D0%BE%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Высокоуровневый язык программирования">высокоуровневых</a>, так и <a href="/wiki/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Низкоуровневый язык программирования">низкоуровневых языков</a>.<sup id="cite_ref-_cd050e120e51c572_3-0" class="reference"><a href="#cite_note-_cd050e120e51c572-3">&#91;3&#93;</a></sup><sup id="cite_ref-_59ba0da17491157e_4-0" class="reference"><a href="#cite_note-_59ba0da17491157e-4">&#91;4&#93;</a></sup> В сравнении с его предшественником&#160;— языком <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">C</a>,&#160;— наибольшее внимание уделено поддержке <a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Объектно-ориентированное программирование">объектно-ориентированного</a> и <a href="/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Обобщённое программирование">обобщённого программирования</a>.<sup id="cite_ref-_59ba0da17491157e_4-1" class="reference"><a href="#cite_note-_59ba0da17491157e-4">&#91;4&#93;</a></sup>
</p><p><b>C++</b> широко используется для разработки программного обеспечения, являясь одним из самых популярных языков программирования<sup id="cite_ref-langpop_5-0" class="reference"><a href="#cite_note-langpop-5">&#91;мнения 1&#93;</a></sup><sup id="cite_ref-tiobe_6-0" class="reference"><a href="#cite_note-tiobe-6">&#91;мнения 2&#93;</a></sup>. Область его применения включает создание <a href="/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0" title="Операционная система">операционных систем</a>, разнообразных прикладных программ, <a href="/wiki/%D0%94%D1%80%D0%B0%D0%B9%D0%B2%D0%B5%D1%80" title="Драйвер">драйверов</a> устройств, приложений для встраиваемых систем, высокопроизводительных серверов, а также игр. Существует множество реализаций языка C++, как бесплатных, так и коммерческих и для различных платформ. Например, на платформе <a href="/wiki/X86" title="X86">x86</a> это <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GCC</a>, <a href="/wiki/Visual_C%2B%2B" class="mw-redirect" title="Visual C++">Visual C++</a>, <a href="/wiki/Intel_C%2B%2B_Compiler" class="mw-redirect" title="Intel C++ Compiler">Intel C++ Compiler</a>, <a href="/wiki/Embarcadero_C%2B%2B_Builder" class="mw-redirect" title="Embarcadero C++ Builder">Embarcadero (Borland) C++ Builder</a> и другие. C++ оказал огромное влияние на другие языки программирования, в первую очередь на <a href="/wiki/Java" title="Java">Java</a> и <a href="/wiki/C_Sharp" title="C Sharp">C#</a>.
</p><p>Синтаксис C++ унаследован от языка <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">C</a>. Одним из принципов разработки было сохранение совместимости с C. Тем не менее, C++ не является в строгом смысле надмножеством C; множество программ, которые могут одинаково успешно транслироваться как <a href="/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80" title="Компилятор">компиляторами</a> C, так и компиляторами C++, довольно велико, но не включает все возможные программы на C.
</p>


<h2><span id=".D0.98.D1.81.D1.82.D0.BE.D1.80.D0.B8.D1.8F"></span><span class="mw-headline" id="История">История</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=1" class="mw-editsection-visualeditor" title="Редактировать раздел «История»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=1" title="Редактировать раздел «История»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<table class="wikitable" align="right">
<tbody><tr>
<th>Исторический этап развития<sup id="cite_ref-7" class="reference"><a href="#cite_note-7">&#91;5&#93;</a></sup></th>
<th>Год
</th></tr>
<tr>
<td>Язык <a href="/wiki/BCPL" title="BCPL">BCPL</a></td>
<td><a href="/wiki/1966" class="mw-redirect" title="1966">1966</a>
</td></tr>
<tr>
<td>Язык <a href="/wiki/%D0%91%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Би (язык программирования)">Би</a> (оригинальная разработка <a href="/wiki/%D0%9A%D0%B5%D0%BD_%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD" class="mw-redirect" title="Кен Томпсон">Томпсона</a> под <a href="/wiki/UNIX" class="mw-redirect" title="UNIX">UNIX</a>)</td>
<td><a href="/wiki/1969" class="mw-redirect" title="1969">1969</a>
</td></tr>
<tr>
<td>Язык <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">Си</a></td>
<td><a href="/wiki/1972" class="mw-redirect" title="1972">1972</a>
</td></tr>
<tr>
<td>Си с <a href="/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Класс (программирование)">классами</a></td>
<td><a href="/wiki/1980" class="mw-redirect" title="1980">1980</a>
</td></tr>
<tr>
<td>C84</td>
<td><a href="/wiki/1984" class="mw-redirect" title="1984">1984</a>
</td></tr>
<tr>
<td><a href="/w/index.php?title=Cfront&amp;action=edit&amp;redlink=1" class="new" title="Cfront (страница отсутствует)">Cfront</a> (выпуск E)</td>
<td><a href="/wiki/1984" class="mw-redirect" title="1984">1984</a>
</td></tr>
<tr>
<td>Cfront (выпуск 1.0)</td>
<td><a href="/wiki/1985" class="mw-redirect" title="1985">1985</a>
</td></tr>
<tr>
<td>Множественное/виртуальное наследование</td>
<td><a href="/wiki/1988" class="mw-redirect" title="1988">1988</a>
</td></tr>
<tr>
<td>Обобщённое программирование (<a href="/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_C%2B%2B" title="Шаблоны C++">шаблоны</a>)</td>
<td><a href="/wiki/1991" class="mw-redirect" title="1991">1991</a>
</td></tr>
<tr>
<td>ANSI C++ / ISO-C++</td>
<td><a href="/wiki/1996" class="mw-redirect" title="1996">1996</a>
</td></tr>
<tr>
<td>ISO/IEC 14882:1998</td>
<td><a href="/wiki/1998" class="mw-redirect" title="1998">1998</a>
</td></tr>
<tr>
<td>ISO/IEC 14882:2003</td>
<td><a href="/wiki/2003" class="mw-redirect" title="2003">2003</a>
</td></tr>
<tr>
<td><a href="/wiki/C%2B%2B/CLI" title="C++/CLI">C++/CLI</a></td>
<td><a href="/wiki/2005" class="mw-redirect" title="2005">2005</a>
</td></tr>
<tr>
<td><a href="/wiki/C%2B%2B_Technical_Report_1" title="C++ Technical Report 1">TR1</a></td>
<td><a href="/wiki/2005" class="mw-redirect" title="2005">2005</a>
</td></tr>
<tr>
<td><a href="/wiki/C%2B%2B11" title="C++11">C++11</a></td>
<td><a href="/wiki/2011" class="mw-redirect" title="2011">2011</a>
</td></tr>
<tr>
<td><a href="/wiki/C%2B%2B14" title="C++14">C++14</a></td>
<td><a href="/wiki/2014" class="mw-redirect" title="2014">2014</a>
</td></tr>
<tr>
<td><a href="/wiki/C%2B%2B17" title="C++17">C++17</a></td>
<td><a href="/wiki/2017" class="mw-redirect" title="2017">2017</a>
</td></tr>
<tr>
<td><a href="/wiki/C%2B%2B20" title="C++20">C++20</a>
</td>
<td><a href="/wiki/2020_%D0%B3%D0%BE%D0%B4" title="2020 год">2020</a>
</td></tr></tbody></table>
<h3><span id=".D0.A1.D0.BE.D0.B7.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5"></span><span class="mw-headline" id="Создание">Создание</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=2" class="mw-editsection-visualeditor" title="Редактировать раздел «Создание»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=2" title="Редактировать раздел «Создание»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Язык возник в начале <a href="/wiki/1980-%D0%B5_%D0%B3%D0%BE%D0%B4%D1%8B" title="1980-е годы">1980-х годов</a>, когда сотрудник фирмы <a href="/wiki/Bell_Labs" class="mw-redirect" title="Bell Labs">Bell Labs</a> <a href="/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%83%D1%81%D1%82%D1%80%D1%83%D0%BF,_%D0%91%D1%8C%D1%91%D1%80%D0%BD" title="Страуструп, Бьёрн">Бьёрн Страуструп</a> придумал ряд усовершенствований к языку <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">C</a> под собственные нужды.
<sup id="cite_ref-_ea7347a0a19ae285_8-0" class="reference"><a href="#cite_note-_ea7347a0a19ae285-8">&#91;6&#93;</a></sup> Когда в конце <a href="/wiki/1970-%D0%B5_%D0%B3%D0%BE%D0%B4%D1%8B" title="1970-е годы">1970-х годов</a> Страуструп начал работать в Bell Labs над задачами теории очередей (в приложении к моделированию телефонных вызовов), он обнаружил, что попытки применения существующих в то время языков моделирования оказываются неэффективными, а применение высокоэффективных машинных языков слишком сложно из-за их ограниченной выразительности. Так, язык <a href="/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0" title="Симула">Симула</a> имеет такие возможности, которые были бы очень полезны для разработки большого программного обеспечения, но работает слишком медленно, а язык <a href="/wiki/BCPL" title="BCPL">BCPL</a> достаточно быстр, но слишком близок к языкам низкого уровня и не подходит для разработки большого программного обеспечения.
</p><p>Вспомнив опыт своей диссертации, Страуструп решил дополнить язык C (преемник BCPL) возможностями, имеющимися в языке Симула. Язык C, будучи базовым языком системы <a href="/wiki/UNIX" class="mw-redirect" title="UNIX">UNIX</a>, на которой работали компьютеры Bell, является быстрым, многофункциональным и переносимым. Страуструп добавил к нему возможность работы с классами и объектами. В результате практические задачи моделирования оказались доступными для решения как с точки зрения времени разработки (благодаря использованию Симула-подобных классов), так и с точки зрения времени вычислений (благодаря быстродействию C). В первую очередь в C были добавлены классы (с <a href="/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Инкапсуляция (программирование)">инкапсуляцией</a>), наследование классов, строгая проверка типов, inline-функции и <a href="/wiki/%D0%90%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82_%D0%BF%D0%BE_%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E" title="Аргумент по умолчанию">аргументы по умолчанию</a>. Ранние версии языка, первоначально именовавшегося «C with classes» («Си с классами»), стали доступны с <a href="/wiki/1980_%D0%B3%D0%BE%D0%B4" title="1980 год">1980 года</a>.
</p><p>Разрабатывая <i>C с классами</i>, Страуструп написал программу <span class="iw plainlinks" data-title="Cfront" data-lang="en" data-lang-name="англ."><a href="/w/index.php?title=Cfront&amp;action=edit&amp;redlink=1" class="new" title="Cfront (страница отсутствует)">cfront</a><sup class="iw&#95;_note noprint" style="font-style:normal; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/cfront" class="extiw" title="en:cfront"><span class="iw&#95;_tooltip" title="cfront — версия статьи «Cfront» на английском языке">[en]</span></a></sup></span>&#160;— <a href="/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BB%D1%8F%D1%82%D0%BE%D1%80" title="Транслятор">транслятор</a>, перерабатывающий исходный код <i>C с классами</i> в исходный код простого C. Это позволило работать над новым языком и использовать его на практике, применяя уже имеющуюся в UNIX инфраструктуру для разработки на C. Новый язык, неожиданно для автора, приобрёл большую популярность среди коллег и вскоре Страуструп уже не мог лично поддерживать его, отвечая на тысячи вопросов.
</p><p>К <a href="/wiki/1983_%D0%B3%D0%BE%D0%B4" title="1983 год">1983 году</a> в язык были добавлены новые возможности, такие как виртуальные функции, перегрузка функций и операторов, ссылки, константы, пользовательский контроль над управлением свободной памятью, улучшенная проверка типов и новый стиль комментариев (<code>//</code>). Получившийся язык уже перестал быть просто дополненной версией классического C и был переименован из <i>C с классами</i> в «C++». Его первый коммерческий выпуск состоялся в октябре <a href="/wiki/1985_%D0%B3%D0%BE%D0%B4" title="1985 год">1985 года</a>.
</p><p>До начала официальной стандартизации язык развивался в основном силами Страуструпа в ответ на запросы программистского сообщества. Функцию стандартных описаний языка выполняли написанные Страуструпом печатные работы по C++ (описание языка, справочное руководство и так далее). Лишь в <a href="/wiki/1998_%D0%B3%D0%BE%D0%B4" title="1998 год">1998 году</a> был ратифицирован международный стандарт языка C++: ISO/IEC 14882:1998 «Standard for the C++ Programming Language»; после принятия технических исправлений к стандарту в <a href="/wiki/2003_%D0%B3%D0%BE%D0%B4" title="2003 год">2003 году</a>&#160;— следующая версия этого стандарта&#160;— ISO/IEC 14882:2003.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9">&#91;7&#93;</a></sup>
</p>
<h3><span id=".D0.A0.D0.B0.D0.B7.D0.B2.D0.B8.D1.82.D0.B8.D0.B5_.D0.B8_.D1.81.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"></span><span class="mw-headline" id="Развитие_и_стандартизация_языка">Развитие и стандартизация языка</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=3" class="mw-editsection-visualeditor" title="Редактировать раздел «Развитие и стандартизация языка»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=3" title="Редактировать раздел «Развитие и стандартизация языка»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>В <a href="/wiki/1985_%D0%B3%D0%BE%D0%B4" title="1985 год">1985 году</a> вышло первое издание «<a href="/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_C%2B%2B_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)" title="Язык программирования C++ (книга)">Языка программирования C++</a>», обеспечивающее первое описание этого языка, что было чрезвычайно важно из-за отсутствия официального стандарта. В <a href="/wiki/1989_%D0%B3%D0%BE%D0%B4" title="1989 год">1989 году</a> состоялся выход C++ версии 2.0. Его новые возможности включали множественное наследование, абстрактные классы, статические функции-члены, функции-константы и защищённые члены. В <a href="/wiki/1990_%D0%B3%D0%BE%D0%B4" title="1990 год">1990 году</a> вышло «Комментированное справочное руководство по C++», положенное впоследствии в основу стандарта. Последние обновления включали шаблоны, исключения, пространства имён, новые способы приведения типов и булевский тип.
</p><p>Стандартная библиотека C++ также развивалась вместе с ним. Первым добавлением к стандартной библиотеке C++ стали потоки ввода-вывода, обеспечивающие средства для замены традиционных функций C <code>printf</code> и <code>scanf</code>. Позднее самым значительным развитием стандартной библиотеки стало включение в неё <a href="/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2" title="Стандартная библиотека шаблонов">Стандартной библиотеки шаблонов</a>.
</p><p>В <a href="/wiki/1998_%D0%B3%D0%BE%D0%B4" title="1998 год">1998 году</a> был опубликован стандарт языка ISO/IEC 14882:1998 (известный как C++98),<sup id="cite_ref-10" class="reference"><a href="#cite_note-10">&#91;8&#93;</a></sup> разработанный комитетом по стандартизации C++ (<a href="/wiki/International_Organization_for_Standardization" class="mw-redirect" title="International Organization for Standardization">ISO</a>/<a href="/wiki/International_Electrotechnical_Commission" class="mw-redirect" title="International Electrotechnical Commission">IEC</a> JTC1/SC22/WG21 working group). Стандарт C++ не описывает способы именования объектов, некоторые детали обработки исключений и другие возможности, связанные с деталями реализации, что делает несовместимым объектный код, созданный различными компиляторами. Однако для этого третьими лицами создано множество стандартов для конкретных <a href="/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%B0" title="Архитектура компьютера">архитектур</a> и <a href="/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0" title="Операционная система">операционных систем</a>.
</p><p>В <a href="/wiki/2003_%D0%B3%D0%BE%D0%B4" title="2003 год">2003 году</a> был опубликован стандарт языка ISO/IEC 14882:2003, где были исправлены выявленные ошибки и недочёты предыдущей версии стандарта.
</p><p>В <a href="/wiki/2005_%D0%B3%D0%BE%D0%B4" title="2005 год">2005 году</a> был выпущен отчёт Library Technical Report 1 (кратко называемый TR1). Не являясь официально частью стандарта, отчёт описывает расширения стандартной библиотеки, которые, как ожидалось авторами, должны быть включены в следующую версию языка C++. Степень поддержки TR1 улучшается почти во всех поддерживаемых компиляторах языка C++.
</p><p>С <a href="/wiki/2009_%D0%B3%D0%BE%D0%B4" title="2009 год">2009 года</a> велась работа по обновлению предыдущего стандарта. Предварительной версией нового стандарта сперва был C++09, а спустя год&#160;— C++0x (впоследствии переименованный в C++11), куда были включены дополнения в ядро языка и расширение стандартной библиотеки, в том числе большую часть TR1.
</p><p>C++ продолжает развиваться, чтобы отвечать современным требованиям. Одна из групп, разрабатывающих язык C++ и направляющих комитету по стандартизации C++ предложения по его улучшению&#160;— это <a href="/wiki/Boost" title="Boost">Boost</a>, которая занимается, в том числе, совершенствованием возможностей языка путём добавления в него особенностей <a href="/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Метапрограммирование">метапрограммирования</a>.
</p><p>Никто не обладает правами на язык C++, он является свободным. Однако сам документ стандарта языка (за исключением черновиков) не доступен бесплатно.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11">&#91;9&#93;</a></sup> В рамках процесса стандартизации, ISO выпускает несколько видов изданий. В частности, технические доклады и технические характеристики публикуются, когда «видно будущее, но нет немедленной возможности соглашения для публикации международного стандарта.» До 2011 года было опубликовано три технических отчёта по C++: TR 19768: 2007 (также известный как C++, Технический отчёт 1) для расширений библиотеки в основном интегрирован в C++11, TR 29124: 2010 для специальных математических функций, и TR 24733: 2011 для десятичной арифметики с плавающей точкой. Техническая спецификация DTS 18822:. 2 014 (по файловой системе) была утверждена в начале 2015 года, и остальные технические характеристики находятся в стадии разработки и ожидают одобрения<sup id="cite_ref-12" class="reference"><a href="#cite_note-12">&#91;10&#93;</a></sup>
</p><p>В марте 2016 года в России была создана рабочая группа <a href="/wiki/%D0%A0%D0%9321_%D0%A1%2B%2B" title="РГ21 С++">РГ21 С++</a>. Группа была организована для сбора предложений к стандарту C++, отправки их в комитет и защиты на общих собраниях Международной организации по стандартизации (ISO)<sup id="cite_ref-sozd_13-0" class="reference"><a href="#cite_note-sozd-13">&#91;11&#93;</a></sup>.
</p>
<h3><span id=".D0.98.D1.81.D1.82.D0.BE.D1.80.D0.B8.D1.8F_.D0.BD.D0.B0.D0.B7.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"></span><span class="mw-headline" id="История_названия">История названия</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=4" class="mw-editsection-visualeditor" title="Редактировать раздел «История названия»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=4" title="Редактировать раздел «История названия»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Имя языка, получившееся в итоге, происходит от оператора унарного постфиксного <i><a href="/wiki/%D0%98%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82" title="Инкремент">инкремента</a></i> C <code>++</code> (увеличение значения переменной на единицу). Имя C+ не было использовано потому, что является синтаксической ошибкой в <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">C</a> и, кроме того, это имя было занято другим языком. Язык также не был назван D, поскольку «<i>является расширением C и не пытается устранять проблемы путём удаления элементов C</i>».<sup id="cite_ref-_ea7347a0a19ae285_8-1" class="reference"><a href="#cite_note-_ea7347a0a19ae285-8">&#91;6&#93;</a></sup>
</p>
<h3><span id=".D0.A4.D0.B8.D0.BB.D0.BE.D1.81.D0.BE.D1.84.D0.B8.D1.8F_C.2B.2B"></span><span class="mw-headline" id="Философия_C++">Философия C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=5" class="mw-editsection-visualeditor" title="Редактировать раздел «Философия C++»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=5" title="Редактировать раздел «Философия C++»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>В книге «Дизайн и эволюция C++» <sup id="cite_ref-_1ff3a236e99a77e1_14-0" class="reference"><a href="#cite_note-_1ff3a236e99a77e1-14">&#91;12&#93;</a></sup> <a href="/wiki/%D0%91%D1%8C%D1%91%D1%80%D0%BD_%D0%A1%D1%82%D1%80%D0%B0%D1%83%D1%81%D1%82%D1%80%D1%83%D0%BF" class="mw-redirect" title="Бьёрн Страуструп">Бьёрн Страуструп</a> описывает принципы, которых он придерживался при проектировании C++. Эти принципы объясняют, почему C++ именно такой, какой он есть. Некоторые из них:
</p>
<ul><li>Получить универсальный язык со статическими типами данных, эффективностью и переносимостью языка C.</li>
<li>Непосредственно и всесторонне поддерживать множество стилей программирования, в том числе <a href="/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Процедурное программирование">процедурное программирование</a>, <a href="/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85" title="Абстракция данных">абстракцию данных</a>, <a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Объектно-ориентированное программирование">объектно-ориентированное программирование</a> и <a href="/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Обобщённое программирование">обобщённое программирование</a>.</li>
<li>Дать программисту свободу выбора, даже если это даст ему возможность выбирать неправильно.</li>
<li>Максимально сохранить совместимость с C, тем самым делая возможным лёгкий переход от программирования на C.</li>
<li>Избежать разночтений между C и C++: любая конструкция, допустимая в обоих языках, должна в каждом из них обозначать одно и то же и приводить к одному и тому же поведению программы.</li>
<li>Избегать особенностей, которые зависят от платформы или не являются универсальными.</li>
<li>«Не платить за то, что не используется»&#160;— никакое языковое средство не должно приводить к снижению производительности программ, не использующих его.</li>
<li>Не требовать слишком усложнённой среды программирования.</li></ul>
<h2><span id=".D0.9E.D0.B1.D0.B7.D0.BE.D1.80_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"></span><span class="mw-headline" id="Обзор_языка">Обзор языка</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=6" class="mw-editsection-visualeditor" title="Редактировать раздел «Обзор языка»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=6" title="Редактировать раздел «Обзор языка»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Стандарт C++ состоит из двух основных частей: описание ядра языка и описание стандартной библиотеки.
</p><p>Первое время язык развивался вне формальных рамок, спонтанно, по мере встававших перед ним задач. Развитию языка сопутствовало развитие <a href="/wiki/%D0%9A%D1%80%D0%BE%D1%81%D1%81-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80" title="Кросс-компилятор">кросс-компилятора</a> <a href="/w/index.php?title=Cfront&amp;action=edit&amp;redlink=1" class="new" title="Cfront (страница отсутствует)">cfront</a>. Новшества в языке отражались в изменении номера версии кросс-компилятора. Эти номера версий кросс-компилятора распространялись и на сам язык, но применительно к настоящему времени речь о версиях языка C++ не ведут. Лишь в 1998 году язык стал стандартизированным.
</p>
<ul><li>C++ поддерживает как комментарии в стиле C (<code>/* комментарий */</code>), так и однострочные (<code>// вся оставшаяся часть строки является комментарием</code>), где <code>//</code> обозначает начало комментария, а ближайший последующий символ новой строки, который не предварён символом <code>\</code> (либо эквивалентным ему обозначением <code>??/</code>), считается окончанием комментария. Плюс этого комментария в том, что его не обязательно заканчивать, то есть обозначать окончание комментария.</li>
<li>Спецификатор <code>inline</code> для функций. Функция, определённая внутри тела класса, является inline по умолчанию. Данный спецификатор является подсказкой компилятору и может встроить тело функции в код вместо её непосредственного вызова.</li>
<li>Квалификаторы <code>const</code> и <code>volatile</code>. В отличие от С, где <code>const</code> обозначает только доступ на чтение, в C++ переменная с квалификатором  <code>const</code> должна быть инициализирована. <code>volatile</code> используется в описании переменных и информирует компилятор, что значение данной переменной может быть изменено способом, который компилятор не в состоянии отследить. Для переменных, объявленных <code>volatile</code>, компилятор не должен применять средства оптимизации, изменяющие положение переменной в памяти (например, помещающие её в регистр) или полагающиеся на неизменность значения переменной в промежутке между двумя присваиваниями ей значения. В многоядерной системе volatile помогает избегать <a href="/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8" title="Барьер памяти">барьеров памяти</a> 2-го типа<span style="background: #ffeaea; color: #444444;"></span><sup class="noprint" style="white-space: nowrap">&#91;<i><a href="/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D0%BD%D0%B0_%D0%B8%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8" title="Википедия:Ссылки на источники"><span title="не указан источник на утверждение (31 мая 2013)" style="">источник не указан 2570 дней</span></a></i>&#93;</sup>.</li>
<li><a href="/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%B8%D0%BC%D1%91%D0%BD_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#C++" title="Пространство имён (программирование)">Пространства имён</a> (namespace). Пример:</li></ul>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">namespace</span> <span class="n">Foo</span>
<span class="p">{</span>
   <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">::</span><span class="n">x</span><span class="p">;</span>
</pre></div>
<p>Специальным случаем является безымянное пространство имён. Все имена, описанные в нём, доступны только в текущей единице трансляции и имеют локальное связывание. Пространство имён <code>std</code> содержит в себе стандартные библиотеки C++.
</p>
<ul><li>Для работы с памятью введены операторы <code>new</code>, <code>new[]</code>, <code>delete</code> и <code>delete[]</code>. В отличие от библиотечных malloc и free, пришедших из C, данные операторы производят инициализацию объекта. Для классов это вызов конструктора, для <a href="/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85" title="Простая структура данных">POD</a> типов инициализацию можно либо не проводить(<code>new Pod;</code>), либо провести инициализацию нулевыми значениями (<code>new Pod(); new Pod{};</code>).</li></ul>
<h3><span id=".D0.A2.D0.B8.D0.BF.D1.8B"></span><span class="mw-headline" id="Типы">Типы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=7" class="mw-editsection-visualeditor" title="Редактировать раздел «Типы»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=7" title="Редактировать раздел «Типы»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>В C++ доступны следующие встроенные типы. Типы C++ практически полностью повторяют <a href="/wiki/%D0%A2%D0%B8%D0%BF%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%B2_C" class="mw-redirect" title="Типы данных в C">типы данных в C</a>:
</p>
<ul><li>Символьные: <code>char</code>, <code>wchar_t</code> (<code>char16_t</code> и <code>char32_t</code>, в стандарте <a href="/wiki/C%2B%2B11" title="C++11">C++11</a>).</li>
<li>Целочисленные знаковые: <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code> (и <code>long long</code>, в стандарте <a href="/wiki/C%2B%2B11" title="C++11">C++11</a>).</li>
<li>Целочисленные беззнаковые: <code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>(и <code>unsigned long long</code>, в стандарте <a href="/wiki/C%2B%2B11" title="C++11">C++11</a>).</li>
<li>С <a href="/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9" title="Число с плавающей запятой">плавающей точкой</a>: <code>float</code>, <code>double</code>, <code>long double</code>.</li>
<li>Логический: <code>bool</code>, имеющий значения <code>true</code> или <code>false</code>.</li></ul>
<p>Операции сравнения возвращают тип <code>bool</code>. Выражения в скобках после <code>if</code>, <code>while</code> <a href="/wiki/%D0%9F%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D1%82%D0%B8%D0%BF%D0%B0#Неявное_приведение" title="Приведение типа">приводятся к типу</a> <code>bool</code>.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15">&#91;13&#93;</a></sup>
</p><p>Язык ввёл понятие ссылок, а начиная с одиннадцатой версии стандарта <i>rvalue</i>-ссылки и <a href="/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D0%B2%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0" class="mw-redirect" title="Передаваемая ссылка">передаваемые ссылки</a> (<a href="/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA" title="Английский язык">англ.</a>&#160;<span lang="en" style="font-style:italic;">forwarding reference</span>). (см. <a href="/wiki/%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B0_(C%2B%2B)" class="mw-redirect" title="Ссылка (C++)">Ссылка (C++)</a>)
</p><p>C++ добавляет к C объектно-ориентированные возможности. Он вводит классы, которые обеспечивают три самых важных свойства <a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Объектно-ориентированное программирование">ООП</a>: <a href="/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Инкапсуляция (программирование)">инкапсуляцию</a>, <a href="/wiki/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Наследование (программирование)">наследование</a> и <a href="/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" class="mw-redirect" title="Полиморфизм (программирование)">полиморфизм</a>.
</p><p>В стандарте C++ под классом (class) подразумевается пользовательский тип, объявленный с использованием одного из ключевых слов <code>class</code>, <code>struct</code> или <code>union</code>, под структурой (structure) подразумевается класс, определённый через ключевое слово struct, и под объединением (union) подразумевается класс, определённый через ключевое слово union.
</p><p>В теле определения класса можно указать как объявления функций, так и их определение. В последнем случае функция является встраиваемой (<code>inline</code>)). Нестатические функции-члены могут иметь квалификаторы const и volatile, а также ссылочный квалификатор (&amp; или &amp;&amp;).
</p>
<h3><span id=".D0.9D.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5"></span><span class="mw-headline" id="Наследование"><a href="/wiki/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Наследование (программирование)">Наследование</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=8" class="mw-editsection-visualeditor" title="Редактировать раздел «Наследование»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=8" title="Редактировать раздел «Наследование»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++ поддерживает <a href="/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Множественное наследование">множественное наследование</a>. Базовые классы (классы-предки) указываются в заголовке описания класса, возможно, со спецификаторами доступа. Наследование от каждого класса может быть публичным, защищённым или закрытым:
</p>
<table class="wikitable">
<tbody><tr>
<th>Доступ члена базового класса/режим наследования</th>
<th>private-член</th>
<th>protected-член</th>
<th>public-член
</th></tr>
<tr>
<td>private-наследование</td>
<td>недоступен</td>
<td>private</td>
<td>private
</td></tr>
<tr>
<td>protected-наследование</td>
<td>недоступен</td>
<td>protected</td>
<td>protected
</td></tr>
<tr>
<td>public-наследование</td>
<td>недоступен</td>
<td>protected</td>
<td>public
</td></tr></tbody></table>
<p>По умолчанию базовый класс наследуется как private.
</p><p>В результате наследования класс-потомок получает все поля классов-предков и все их методы; можно сказать, что каждый экземпляр класса-потомка содержит <i>подэкземпляр</i> каждого из классов-предков. Если один класс-предок наследуется несколько раз (это возможно, если он является предком нескольких базовых классов создаваемого класса), то экземпляры класса-потомка будет включать столько же подэкземпляров данного класса-предка. Чтобы избежать такого эффекта, если он нежелателен, C++ поддерживает концепцию <i>виртуального наследования</i>. При наследовании базовый класс может объявляться виртуальным; на все виртуальные вхождения класса-предка в дерево наследования класса-потомка в потомке создаётся только один подэкземпляр.
</p>
<div class="hatnote dabhide">См. также: <a href="/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Виртуальное наследование">Виртуальное наследование</a></div>
<h3><span id=".D0.9F.D0.BE.D0.BB.D0.B8.D0.BC.D0.BE.D1.80.D1.84.D0.B8.D0.B7.D0.BC"></span><span class="mw-headline" id="Полиморфизм"><a href="/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" class="mw-redirect" title="Полиморфизм (программирование)">Полиморфизм</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=9" class="mw-editsection-visualeditor" title="Редактировать раздел «Полиморфизм»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=9" title="Редактировать раздел «Полиморфизм»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++ поддерживает динамический полиморфизм и <a href="/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC" title="Параметрический полиморфизм">параметрический полиморфизм</a>.
</p><p>Параметрический полиморфизм представлен:
</p>
<ul><li>Аргументами по умолчанию для функций. К примеру, для функции <code>void f(int x, int y=5, int z=10)</code>, вызовы <code>f(1)</code>, <code>f(1,5)</code> и <code>f(1,5,10)</code> эквивалентны.</li>
<li><a href="/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9" class="mw-redirect" title="Перегрузка функций">Перегрузка функций</a>: функция с одним именем может иметь разное число и разные по типу аргументы. Например&#160;: <div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</pre></div></li></ul>
<dl><dd><dl><dd>Частным случаем перегрузки функций можно считать <a href="/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2#Перегрузка_операторов_в_C++" title="Перегрузка операторов">перегрузку операторов</a>.</dd></dl></dd></dl>
<ul><li>Механизмом шаблонов</li></ul>
<p>Динамический полиморфизм реализуется с помощью <a href="/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4" title="Виртуальный метод">виртуальных методов</a> и иерархии наследования. Полиморфным в C++ является тип имеющий хотя бы один виртуальный метод. Пример иерархии:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">Figure</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// чистый виртуальный метод</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Figure</span><span class="p">();</span>       <span class="c1">// при наличии хотя бы одного виртуального метода деструктор следует сделать виртуальным</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Figure</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Draw</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Figure</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Draw</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>Здесь класс Figure является <a href="/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BB%D0%B0%D1%81%D1%81" title="Абстрактный класс">абстрактным</a> (и, даже, <a href="/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Интерфейс (объектно-ориентированное программирование)">интерфейсным</a>), так как метод Draw не определён. Объекты данного класса нельзя создать, зато можно использовать ссылки или указатели с типом Figure. Выбор реализации метода Draw будет производиться во время выполнения исходя из реального типа объекта.
</p>
<h3><span id=".D0.98.D0.BD.D0.BA.D0.B0.D0.BF.D1.81.D1.83.D0.BB.D1.8F.D1.86.D0.B8.D1.8F"></span><span class="mw-headline" id="Инкапсуляция"><a href="/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Инкапсуляция (программирование)">Инкапсуляция</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=10" class="mw-editsection-visualeditor" title="Редактировать раздел «Инкапсуляция»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=10" title="Редактировать раздел «Инкапсуляция»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Инкапсуляция в C++ реализуется через указание уровня доступа к членам класса: они бывают публичными (открытыми, <code>public</code>), защищёнными (<code>protected</code>) и приватными (закрытыми, <code>private</code>). В C++ структуры формально отличаются от классов лишь тем, что по умолчанию уровень доступа к членам класса и тип наследования у структуры публичные, а у класса&#160;— приватные.
</p>
<table class="wikitable">
<tbody><tr>
<th>Доступ</th>
<th>private</th>
<th>protected</th>
<th>public
</th></tr>
<tr>
<td>Сам класс</td>
<td>да</td>
<td>да</td>
<td>да
</td></tr>
<tr>
<td><a href="#Друзья">Друзья</a></td>
<td>да</td>
<td>да</td>
<td>да
</td></tr>
<tr>
<td>Наследники</td>
<td>нет</td>
<td>да</td>
<td>да
</td></tr>
<tr>
<td>Извне</td>
<td>нет</td>
<td>нет</td>
<td>да
</td></tr></tbody></table>
<p>Проверка доступа происходит во время компиляции, попытка обращения к недоступному члену класса вызовет ошибку компиляции.
</p>
<h4><span id=".D0.94.D1.80.D1.83.D0.B7.D1.8C.D1.8F"></span><span class="mw-headline" id="Друзья">Друзья</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=11" class="mw-editsection-visualeditor" title="Редактировать раздел «Друзья»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=11" title="Редактировать раздел «Друзья»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p><i>Функции-друзья</i>&#160;— это функции, не являющиеся функциями-членами и тем не менее имеющие доступ к защищённым и закрытым членам класса. Они должны быть объявлены в теле класса как <code>friend</code>. Например:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="n">Matrix</span> <span class="n">Multiply</span><span class="p">(</span><span class="n">Matrix</span> <span class="n">m1</span><span class="p">,</span> <span class="n">Matrix</span> <span class="n">m2</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
<p>Здесь функция <code>Multiply</code> может обращаться к любым полям и функциям-членам класса <code>Matrix</code>.
</p><p>Дружественным может быть объявлен как весь класс, так и функция-член класса.
Четыре важных ограничения, накладываемых на отношения дружественности в C++:
</p>
<ul><li><b>Дружественность не транзитивна.</b> Если A объявляет другом B, а B, в свою очередь, объявляет другом C, то C не становится автоматически другом для A. Для этого A должен явно объявить C своим другом.</li>
<li><b>Дружественность не взаимна.</b> Если класс A объявляет другом класс B, то он не становится автоматически другом для B. Для этого должно существовать явное объявление дружественности A в классе B.</li>
<li><b>Дружественность не наследуется.</b> Если A объявляет класс B своим другом, то потомки B не становятся автоматически друзьями A. Для этого каждый из них должен быть объявлен другом A в явной форме.</li>
<li><b>Дружественность не распространяется на потомков.</b> Если класс A объявляет B другом, то B не становится автоматически другом для классов-потомков A. Каждый потомок, если это нужно, должен объявить B своим другом самостоятельно.</li></ul>
<p>В общем виде это правило можно сформулировать следующим образом: <i>«Отношение дружественности существует только между теми классами (классом и функцией), для которых оно явно объявлено в коде, и действует только в том направлении, в котором оно объявлено».</i>
</p>
<h3><span id=".D0.A1.D0.BF.D0.B5.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Специальные_функции">Специальные функции</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=12" class="mw-editsection-visualeditor" title="Редактировать раздел «Специальные функции»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=12" title="Редактировать раздел «Специальные функции»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Класс по умолчанию может иметь шесть специальных функций: конструктор по умолчанию, конструктор копирования, конструктор перемещения, деструктор, оператор присваивания копированием, оператор присваивания перемещением. Также можно явно определить их все (см. <a href="/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D1%82%D1%80%D1%91%D1%85_(C%2B%2B_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" class="mw-redirect" title="Правило трёх (C++ программирование)">Правило трёх</a>).
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Array</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// компилятор создаст конструктор по-умолчанию сам</span>
	<span class="n">Array</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">_len</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">len</span><span class="p">(</span><span class="n">_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">_len</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">Array</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// конструктор копирования явно удалён</span>
	<span class="n">Array</span><span class="p">(</span><span class="n">Array</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// конструктор перемещения</span>
	<span class="o">~</span><span class="n">Array</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">delete</span><span class="p">[]</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Array</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// оператор присваивания копированием</span>
	<span class="n">Array</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Array</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// оператор присваивания перемещением</span>
	<span class="kt">double</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// инициализация поля</span>
	<span class="kt">double</span><span class="o">*</span> <span class="n">val</span> <span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
<p>Конструктор вызывается для инициализации объекта (соответствующего типа) при его создании, а деструктор&#160;— для уничтожения объекта. Класс может иметь несколько конструкторов, но деструктор может иметь только один. Конструкторы в C++ не могут быть объявлены виртуальными, а деструкторы&#160;— могут, и обычно объявляются для всех полиморфных типов, чтобы гарантировать правильное уничтожение доступного по ссылке или указателю объекта независимо от того, какого типа ссылка или указатель. При наличии хотя бы у одного из базовых классов виртуального деструктора, деструктор класса потомка автоматически становится виртуальным.
</p>
<h3><span id=".D0.A8.D0.B0.D0.B1.D0.BB.D0.BE.D0.BD.D1.8B"></span><span class="mw-headline" id="Шаблоны">Шаблоны</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=13" class="mw-editsection-visualeditor" title="Редактировать раздел «Шаблоны»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=13" title="Редактировать раздел «Шаблоны»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="hatnote">Основная статья: <b><a href="/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_C%2B%2B" title="Шаблоны C++">Шаблоны C++</a></b></div>
<p>Шаблоны позволяют порождать функции и классы, параметризованные определённым типом или значением. Например, предыдущий класс мог бы реализовывать массив для любого типа данных:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// инициализация поля</span>
	<span class="n">T</span><span class="o">*</span> <span class="n">val</span> <span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
<h2><span id=".D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D0.B0.D1.8F_.D0.B1.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D0.BA.D0.B0"></span><span class="mw-headline" id="Стандартная_библиотека">Стандартная библиотека</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=14" class="mw-editsection-visualeditor" title="Редактировать раздел «Стандартная библиотека»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=14" title="Редактировать раздел «Стандартная библиотека»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span id=".D0.9E.D0.B1.D1.89.D0.B0.D1.8F_.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D1.83.D1.80.D0.B0"></span><span class="mw-headline" id="Общая_структура">Общая структура</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=15" class="mw-editsection-visualeditor" title="Редактировать раздел «Общая структура»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=15" title="Редактировать раздел «Общая структура»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Стандартная библиотека C++ включает в себя набор средств, которые должны быть доступны для любой реализации языка, чтобы обеспечить программистам удобное пользование языковыми средствами и создать базу для разработки как прикладных приложений самого широкого спектра, так и специализированных библиотек. Стандартная библиотека C++ включает в себя часть стандартной библиотеки C. Стандарт C++ содержит нормативную ссылку на стандарт C от <a href="/wiki/1990_%D0%B3%D0%BE%D0%B4" title="1990 год">1990 года</a> и не определяет самостоятельно те функции стандартной библиотеки, которые заимствуются из стандартной библиотеки C.
</p><p>Доступ к возможностям стандартной библиотеки C++ обеспечивается с помощью включения в программу (посредством директивы <code>#include</code>) соответствующих стандартных заголовочных файлов. Всего в стандарте C++11 определено 79 таких файлов. Средства стандартной библиотеки объявляются как входящие в пространство имён std. Заголовочные файлы, имена которых соответствуют шаблону «cX», где X&#160;— имя заголовочного файла стандартной библиотеки C без расширения (cstdlib, cstring, cstdio и пр.), содержат объявления, соответствующие данной части стандартной библиотеки C. Стандартные функции библиотеки C также находятся в пространстве имён std.
</p>
<h3><span id=".D0.A1.D0.BE.D1.81.D1.82.D0.B0.D0.B2"></span><span class="mw-headline" id="Состав">Состав</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=16" class="mw-editsection-visualeditor" title="Редактировать раздел «Состав»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=16" title="Редактировать раздел «Состав»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Стандартная библиотека включает в себя следующие разделы:
</p>
<ul><li><i>Поддержка языка</i>. Включает средства, которые необходимы для работы программ, а также сведения об особенностях реализации. Выделение памяти, <a href="/wiki/RTTI" class="mw-redirect" title="RTTI">RTTI</a>, базовые исключения, пределы значений для числовых типов данных, базовые средства взаимодействия со средой, такие как системные часы, обработка сигналов UNIX, завершение программы.</li>
<li><i>Стандартные <a href="/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Контейнер (программирование)">контейнеры</a></i>. В стандартную библиотеку входят шаблоны для следующих контейнеров: динамический массив(vector), статический массив(array), одно- и двунаправленные списки(list, forward_list), стек(stack), дек(deque), ассоциативные массивы(map, multimap), множества(set, multiset), очередь с приоритетом(priority_queue).</li>
<li><i>Основные утилиты</i>. В этот раздел входит описание основных базовых элементов, применяемых в стандартной библиотеке, <a href="/wiki/%D0%90%D0%BB%D0%BB%D0%BE%D0%BA%D0%B0%D1%82%D0%BE%D1%80" title="Аллокатор">распределителей памяти</a> и поддержка времени и даты в стиле C.</li>
<li><i>Итераторы</i>. Обеспечивают шаблоны <a href="/wiki/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" class="mw-redirect" title="Итератор (программирование)">итераторов</a>, с помощью которых в стандартной библиотеке реализуется стандартный механизм группового применения алгоритмов обработки данных к элементам контейнеров.</li>
<li><i>Алгоритмы</i>. Шаблоны для описания операций обработки, которые с помощью механизмов стандартной библиотеки могут применяться к любой последовательности элементов, в том числе к элементам в контейнерах. Также в этот раздел входят описания функций bsearch() и qsort() из стандартной библиотеки C.</li>
<li><i>Строки</i>. Шаблоны строк в стиле C++. Также в этот раздел попадает часть библиотек для работы со строками и символами в стиле C.</li>
<li><i>Ввод-вывод</i>. Шаблоны и вспомогательные классы для потоков ввода-вывода общего вида, строкового ввода-вывода, манипуляторы (средства управления форматом потокового ввода-вывода в стиле C++).</li>
<li><i>Локализация</i>. Определения, используемые для поддержки национальных особенностей и форматов представления (дат, валют и&#160;т.&#160;д.) в стиле C++ и в стиле C.</li>
<li><i>Диагностика</i>. Определения ряда исключений и механизмов проверки утверждений во время выполнения (assert). Поддержка обработки ошибок в стиле C.</li>
<li><i>Числа</i>. Определения для работы с комплексными числами, математическими векторами, поддержка общих математических функций, генератор случайных чисел.</li></ul>
<p>Контейнеры, строки, алгоритмы, итераторы и основные утилиты, за исключением заимствований из библиотеки C, собирательно называются STL (Standard Template Library&#160;— стандартная шаблонная библиотека). Изначально эта библиотека была отдельным продуктом и её аббревиатура расшифровывалась иначе, но потом она вошла в стандартную библиотеку C++ в качестве неотъемлемого элемента. В названии отражено то, что для реализации средств общего вида (контейнеров, строк, алгоритмов) использованы механизмы обобщённого программирования (шаблоны C++&#160;— template). В работах Страуструпа подробно описываются причины, по которым был сделан именно такой выбор. Основными из них являются бо́льшая универсальность выбранного решения (шаблонные контейнеры, в отличие от объектных, могут легко использоваться для не объектных типов и не требуют наличия общего предка у типов элементов) и его техническая эффективность (как правило, операции шаблонного контейнера не требуют вызовов виртуальных функций и могут легко встраиваться (inline), что в итоге даёт выигрыш в производительности).
</p><p>Начиная со стандарта C++11 добавились следующие возможности:
</p>
<ul><li>Добавлена библиотека &lt;regex&gt;, реализующая общепринятые механизмы поиска и подстановки с помощью регулярных выражений.</li>
<li>Добавлена поддержка многопоточности.</li>
<li>Атомарные операции</li>
<li>unordered варианты ассоциативных массивов и множеств.</li>
<li>Умные указатели, обеспечивающие автоматическое освобождение выделенной памяти.</li></ul>
<h3><span id=".D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Реализации">Реализации</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=17" class="mw-editsection-visualeditor" title="Редактировать раздел «Реализации»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=17" title="Редактировать раздел «Реализации»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>STL до включения в стандарт C++ была сторонней разработкой, вначале — фирмы <a href="/wiki/Hewlett-Packard" title="Hewlett-Packard">HP</a>, а затем <a href="/wiki/SGI" class="mw-redirect" title="SGI">SGI</a>. Стандарт языка не называет её «STL», так как эта библиотека стала неотъемлемой частью языка, однако многие люди до сих пор используют это название, чтобы отличать её от остальной части стандартной библиотеки (потоки ввода-вывода (<a href="/wiki/Iostream" title="Iostream">iostream</a>), подраздел C и другие).
</p><p>Проект под названием STLport<sup id="cite_ref-16" class="reference"><a href="#cite_note-16">&#91;14&#93;</a></sup>, основанный на SGI STL, осуществляет постоянное обновление STL, IOstream и строковых классов. Некоторые другие проекты также занимаются разработкой частных применений стандартной библиотеки.
</p>
<h2><span id=".D0.9E.D1.82.D0.BB.D0.B8.D1.87.D0.B8.D1.8F_.D0.BE.D1.82_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0_C"></span><span class="mw-headline" id="Отличия_от_языка_C">Отличия от языка C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=18" class="mw-editsection-visualeditor" title="Редактировать раздел «Отличия от языка C»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=18" title="Редактировать раздел «Отличия от языка C»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:222px;"><a href="/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:CppCgenealogy.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/e/ea/CppCgenealogy.png/220px-CppCgenealogy.png" decoding="async" width="220" height="366" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/ea/CppCgenealogy.png/330px-CppCgenealogy.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/ea/CppCgenealogy.png/440px-CppCgenealogy.png 2x" data-file-width="454" data-file-height="756" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:CppCgenealogy.png" class="internal" title="Увеличить"></a></div>Генеалогия и взаимовлияние версий C и C++ (по Б. Страуструп, "Язык программирования С++, краткий курс")</div></div></div>
<h3><span id=".D0.A1.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D1.8C_.D1.81_.D1.8F.D0.B7.D1.8B.D0.BA.D0.BE.D0.BC_.D0.A1"></span><span class="mw-headline" id="Совместимость_с_языком_С">Совместимость с языком С</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=19" class="mw-editsection-visualeditor" title="Редактировать раздел «Совместимость с языком С»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=19" title="Редактировать раздел «Совместимость с языком С»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Выбор именно C в качестве базы для создания нового языка программирования объясняется тем, что язык C:
<style data-mw-deduplicate="TemplateStyles:r106630606">.mw-parser-output .ts-Начало_цитаты-quote{padding:0.25em 1em;border:thin solid #eaecf0}.mw-parser-output .ts-Начало_цитаты-source{margin:1em 0 0 5%}.mw-parser-output .ts-Начало_цитаты-quote .ts-oq{margin:0 -1em -0.25em}.mw-parser-output .ts-Начало_цитаты-quote .ts-oq .NavFrame{padding:0}.mw-parser-output .ts-Начало_цитаты-quote .ts-oq .NavHead,.mw-parser-output .ts-Начало_цитаты-quote .ts-oq .NavContent{padding-left:1.052632em;padding-right:1.052632em}</style>
</p>
<blockquote class="ts-Начало_цитаты-quote">
<p class="mw-empty-elt">
</p>
<ol><li>является многоцелевым, лаконичным и относительно низкоуровневым языком;</li>
<li>подходит для решения большинства системных задач;</li>
<li>исполняется везде и на всём;</li>
<li>стыкуется со средой программирования UNIX.</li></ol>
<style data-mw-deduplicate="TemplateStyles:r104610272">.mw-parser-output .ts-Конец_цитаты-source{margin:0.357143em 2em 0 0;text-align:right}</style><div class="ts-Конец_цитаты-source">— <cite>Б. Страуструп. Язык программирования C++. Раздел 1.6<sup id="cite_ref-_0e567011be933344_17-0" class="reference"><a href="#cite_note-_0e567011be933344-17">&#91;15&#93;</a></sup></cite></div></blockquote>
<p>Несмотря на ряд известных недостатков языка C, Страуструп пошёл на его использование в качестве основы, так как «в C есть свои проблемы, но их имел бы и разработанный с нуля язык, а проблемы C нам известны». Кроме того, это позволило быстро получить прототип компилятора (<span class="iw plainlinks" data-title="Cfront" data-lang="en" data-lang-name="англ."><a href="/w/index.php?title=Cfront&amp;action=edit&amp;redlink=1" class="new" title="Cfront (страница отсутствует)">cfront</a><sup class="iw&#95;_note noprint" style="font-style:normal; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/cfront" class="extiw" title="en:cfront"><span class="iw&#95;_tooltip" title="Версия статьи «Cfront» на английском языке">[en]</span></a></sup></span>), который лишь выполнял трансляцию добавленных синтаксических элементов в оригинальный язык C.
</p><p>По мере разработки C++ в него были включены другие средства, которые перекрывали возможности конструкций C, в связи с чем неоднократно поднимался вопрос об отказе от совместимости языков путём удаления устаревших конструкций. Тем не менее, совместимость была сохранена из следующих соображений:
</p>
<ul><li>сохранение действующего кода, написанного изначально на C и прямо перенесённого в C++;</li>
<li>исключение необходимости переучивания программистов, ранее изучавших C (им требуется только изучить новые средства C++);</li>
<li>исключение путаницы между языками при их совместном использовании («если два языка используются совместно, их различия должны быть или минимальными, или настолько большими, чтобы языки было невозможно перепутать»).</li></ul>
<h3><span id=".D0.9D.D0.BE.D0.B2.D1.8B.D0.B5_.D0.B2.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8"></span><span class="mw-headline" id="Новые_возможности">Новые возможности</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=20" class="mw-editsection-visualeditor" title="Редактировать раздел «Новые возможности»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=20" title="Редактировать раздел «Новые возможности»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<style data-mw-deduplicate="TemplateStyles:r104610261">.mw-parser-output .ts-Родственный_проект{background:#f8f9fa;border:1px solid #a2a9b1;clear:right;float:right;font-size:90%;margin:0 0 1em 1em;padding:.4em;max-width:23em;width:23em;line-height:1.5}.mw-parser-output .ts-Родственный_проект th,.mw-parser-output .ts-Родственный_проект td{padding:.2em 0;vertical-align:middle}.mw-parser-output .ts-Родственный_проект th+td{padding-left:.4em}@media(max-width:719px){.mw-parser-output .ts-Родственный_проект{box-sizing:border-box}}</style>
<table class="metadata plainlinks ts-Родственный_проект noprint ruwikiWikimediaNavigation">

<tbody><tr>
<th style="width: 10%"><img alt="Логотип Викиучебника" src="//upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Notification-icon-Wikibooks-logo.svg/40px-Notification-icon-Wikibooks-logo.svg.png" decoding="async" width="40" height="40" class="noviewer" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Notification-icon-Wikibooks-logo.svg/60px-Notification-icon-Wikibooks-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Notification-icon-Wikibooks-logo.svg/80px-Notification-icon-Wikibooks-logo.svg.png 2x" data-file-width="30" data-file-height="30" />
</th>
<td>Имеется <a href="/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA" title="Викиучебник">викиучебник</a> по теме <span class="wikibooks-ref"><b>«<a href="https://ru.wikibooks.org/wiki/%D0%A1%D0%B8%2B%2B" class="extiw" title="b:Си++">Си++</a>»</b></span>
</td></tr></tbody></table>
<p>Новые возможности C++ включают объявления в виде выражений, преобразования типов в виде функций, операторы <code>new</code> и <code>delete</code>, тип <code>bool</code>, ссылки, расширенное понятие константности, подставляемые функции, аргументы по умолчанию, переопределения, пространства имён, классы (включая и все связанные с классами возможности, такие как наследование, функции-члены, виртуальные функции, абстрактные классы и <a href="/wiki/%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0" class="mw-redirect" title="Конструктор класса">конструкторы</a>), переопределения операторов, шаблоны, оператор <code>::</code>, обработку исключений, динамическую идентификацию и многое другое. Язык C++ также во многих случаях строже относится к проверке типов, чем C.
</p><p>В C++ появились комментарии в виде двойной косой черты (<code>//</code>), которые были в предшественнике C&#160;— языке <a href="/wiki/BCPL" title="BCPL">BCPL</a>.
</p><p>Некоторые особенности C++ позднее были перенесены в C, например, ключевые слова <code>const</code> и <code>inline</code>, объявления в циклах <code>for</code> и комментарии в стиле C++ (<code>//</code>). В более поздних реализациях C также были представлены возможности, которых нет в C++, например макросы <code>va_arg</code> и улучшенная работа с массивами-параметрами.
</p>
<h3><span id="C.2B.2B_.D0.BD.D0.B5_.D0.B2.D0.BA.D0.BB.D1.8E.D1.87.D0.B0.D0.B5.D1.82_.D0.B2_.D1.81.D0.B5.D0.B1.D1.8F_C"></span><span class="mw-headline" id="C++_не_включает_в_себя_C">C++ не включает в себя C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=21" class="mw-editsection-visualeditor" title="Редактировать раздел «C++ не включает в себя C»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=21" title="Редактировать раздел «C++ не включает в себя C»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Несмотря на то, что большая часть кода C будет справедлива и для C++, C++ не является надмножеством C и не включает его в себя. Существует и такой верный для C код, который неверен для C++. Это отличает его от <a href="/wiki/Objective_C" class="mw-redirect" title="Objective C">Objective C</a>, ещё одного усовершенствования C для <a href="/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Объектно-ориентированное программирование">ООП</a>, как раз являющегося надмножеством C.
</p><p>Существуют и другие различия. Например, C++ не разрешает вызывать функцию <code>main()</code> внутри программы, в то время как в C это действие правомерно. Кроме того, C++ более строг в некоторых вопросах; например, он не допускает неявное приведение типов между несвязанными типами указателей и не разрешает использовать функции, которые ещё не объявлены.
</p><p>Более того, код, верный для обоих языков, может давать разные результаты в зависимости от того, компилятором какого языка он оттранслирован. Например, на большинстве платформ следующая программа печатает «С», если компилируется компилятором C, и «C++»&#160;— если компилятором C++. Так происходит из-за того, что символьные константы в C (например, <code>'a'</code>) имеют тип <code>int</code>, а в C++&#160;— тип <code>char</code>, а размеры этих типов обычно различаются.
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span> <span class="o">?</span> <span class="s">&quot;C++&quot;</span> <span class="o">:</span> <span class="s">&quot;C&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3><span id=".D0.A1.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B2.D0.B0_C.2C_.D0.BA.D0.BE.D1.82.D0.BE.D1.80.D1.8B.D1.85_.D1.80.D0.B5.D0.BA.D0.BE.D0.BC.D0.B5.D0.BD.D0.B4.D1.83.D0.B5.D1.82.D1.81.D1.8F_.D0.B8.D0.B7.D0.B1.D0.B5.D0.B3.D0.B0.D1.82.D1.8C"></span><span class="mw-headline" id="Средства_C,_которых_рекомендуется_избегать">Средства C, которых рекомендуется избегать</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=22" class="mw-editsection-visualeditor" title="Редактировать раздел «Средства C, которых рекомендуется избегать»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=22" title="Редактировать раздел «Средства C, которых рекомендуется избегать»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>По замечанию Страуструпа, «чем лучше вы знаете C, тем труднее вам будет избежать программирования на C++ в стиле C, теряя при этом потенциальные преимущества C++». В связи с этим он даёт следующий набор рекомендаций для программистов на C, чтобы в полной мере воспользоваться преимуществами C++:
</p>
<ul><li>Не использовать макроопределения <code>#define</code>. Для объявления констант применять <code>const</code>, групп констант (перечислений)&#160;— <code>enum</code>, для прямого включения функций&#160;— <code>inline</code>, для определения семейств функций или типов&#160;— <code>template</code>.</li>
<li>Не использовать предварительные объявления переменных. Объявлять переменные в блоке, где они реально используются, всегда совмещая объявление с инициализацией.</li>
<li>Отказаться от использования <code>malloc()</code><sup id="cite_ref-18" class="reference"><a href="#cite_note-18">&#91;16&#93;</a></sup> в пользу оператора <code>new</code>, от <code>realloc()</code><sup id="cite_ref-19" class="reference"><a href="#cite_note-19">&#91;17&#93;</a></sup>&#160;— в пользу типа <code>vector</code>. Более безопасным будет использование умных указателей, таких как shared_ptr и unique_ptr, доступных с одиннадцатой версии стандарта.</li>
<li>Избегать бестиповых указателей, арифметики указателей, неявных приведений типов, объединений, за исключением, возможно, низкоуровневого кода. Использовать «новые» преобразования типов, как более точно выражающие действительные намерения программиста и более безопасные.</li>
<li>Свести к минимуму использование массивов символов и строк в стиле C, заменив их на типы <code>string</code> и <code>vector</code> из STL. Вообще не стремиться создавать собственные реализации того, что уже имеется в стандартной библиотеке.</li></ul>
<h2><span id=".D0.94.D0.B0.D0.BB.D1.8C.D0.BD.D0.B5.D0.B9.D1.88.D0.B5.D0.B5_.D1.80.D0.B0.D0.B7.D0.B2.D0.B8.D1.82.D0.B8.D0.B5"></span><span class="mw-headline" id="Дальнейшее_развитие">Дальнейшее развитие</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=23" class="mw-editsection-visualeditor" title="Редактировать раздел «Дальнейшее развитие»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=23" title="Редактировать раздел «Дальнейшее развитие»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Текущий стандарт языка ISO/IEC 14882:2017 был опубликован в декабре <a href="/wiki/2017_%D0%B3%D0%BE%D0%B4" title="2017 год">2017 года</a>. Неофициально его обозначают как <a href="/wiki/C%2B%2B17" title="C++17">C++17</a>. Следующая версия стандарта, запланированная на 2020 год, имеет неофициальное обозначение <a href="/wiki/C%2B%2B20" title="C++20">C++20</a>.
</p>
<h3><span id=".D0.9E.D0.B1.D1.89.D0.B8.D0.B5_.D0.BD.D0.B0.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D1.80.D0.B0.D0.B7.D0.B2.D0.B8.D1.82.D0.B8.D1.8F_C.2B.2B"></span><span class="mw-headline" id="Общие_направления_развития_C++">Общие направления развития C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=24" class="mw-editsection-visualeditor" title="Редактировать раздел «Общие направления развития C++»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=24" title="Редактировать раздел «Общие направления развития C++»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>По мнению автора языка Бьёрна Страуструпа<sup id="cite_ref-20" class="reference"><a href="#cite_note-20">&#91;18&#93;</a></sup><sup id="cite_ref-21" class="reference"><a href="#cite_note-21">&#91;19&#93;</a></sup><sup id="cite_ref-22" class="reference"><a href="#cite_note-22">&#91;20&#93;</a></sup>, говоря о дальнейшем развитии и перспективах языка, можно выделить следующее:
</p>
<ul><li>В основном дальнейшее развитие языка будет идти по пути внесения дополнений в стандартную библиотеку. Одним из основных источников этих дополнений является известная библиотека <a href="/wiki/Boost" title="Boost">boost</a>.</li>
<li>Изменения в ядре языка не должны приводить к снижению уже достигнутой эффективности C++. С точки зрения Страуструпа, предпочтительнее внесение в ядро нескольких серьёзных больших изменений, чем множества мелких правок.</li>
<li>Базовыми направлениями развития C++ на ближайшее время является расширение возможностей и доработка средств обобщённого программирования, стандартизация механизмов параллельной обработки, а также доработка средств безопасного программирования, таких как различные проверки и безопасные преобразования типов, проверка условий и так далее.</li>
<li>В целом C++ спроектирован и развивается как мультипарадигменный язык, впитывающий в себя различные методы и технологии программирования, но реализующий их на платформе, обеспечивающей высокую техническую эффективность. Поэтому в будущем не исключено добавление в язык средств функционального программирования, автоматической сборки мусора и других отсутствующих в нём сейчас механизмов. Но в любом случае это будет делаться на имеющейся платформе высокоэффективного компилируемого языка.</li>
<li>Хотя формально одним из принципов C++ остаётся сохранение совместимости с языком C, фактически группы по стандартизации этих языков не взаимодействуют, а вносимые ими изменения не только не коррелируют, но и нередко принципиально противоречат друг другу идеологически. Так, элементы, которые новые стандарты C добавляют в ядро, в стандарте C++ являются элементами стандартной библиотеки и в ядре вообще отсутствуют, например, динамические массивы, массивы с фиксированными границами, средства параллельной обработки. Как считает Страуструп, объединение разработки этих двух языков принесло бы большую пользу, но оно вряд ли возможно по политическим соображениям. Так что практическая совместимость между C и C++ постепенно будет утрачиваться.</li></ul>
<h3><span id=".D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82_C.2B.2B11:_.D0.B4.D0.BE.D0.BF.D0.BE.D0.BB.D0.BD.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B2_.D1.8F.D0.B4.D1.80.D0.B5_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"></span><span class="mw-headline" id="Стандарт_C++11:_дополнения_в_ядре_языка">Стандарт C++11: дополнения в ядре языка</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=25" class="mw-editsection-visualeditor" title="Редактировать раздел «Стандарт C++11: дополнения в ядре языка»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=25" title="Редактировать раздел «Стандарт C++11: дополнения в ядре языка»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="hatnote">Основная статья: <b><a href="/wiki/C%2B%2B11" title="C++11">C++11</a></b></div>
<ul><li>Явно определяемые константные функции и выражения <b>constexpr</b>.</li>
<li>Универсальная инициализация.</li>
<li>Конструкторы и операторы присваивания с семантикой переноса.</li>
<li>Вывод типов.</li></ul>
<dl><dd><dl><dd>Для применения в шаблонах, там, где затруднительно указать конкретный тип переменной, введены два новых механизма: переменные типа <b>auto</b> и описание <b>decltype</b>.</dd></dl></dd></dl>
<ul><li>Цикл по коллекции.</li></ul>
<dl><dd><dl><dd>Вслед за многими современными языками в C++ введена конструкция «цикл по коллекции» вида <b><code>for(type &amp;x&#160;: array){...}</code></b>. Здесь тело цикла выполняется для каждого элемента коллекции <b>array</b>, а <b>x</b> в каждой итерации будет ссылаться на очередной элемент коллекции. В качестве коллекции может выступать C-массив или любой контейнер стандартной библиотеки, для которого определены итераторы <b>begin</b> и <b>end</b>.</dd></dl></dd></dl>
<ul><li>Лямбда-выражения.</li></ul>
<dl><dd><dl><dd>Добавлена возможность объявлять лямбда-выражения (безымянные функции, определяемые в точке применения), в том числе зависящие от внешних переменных (замыкания). Лямбда-выражения могут присваиваться переменным и использоваться везде, где требуется функция соответствующего типа, например, в алгоритмах стандартной библиотеки.</dd></dl></dd></dl>
<ul><li>Изменения в описании виртуальных методов.</li></ul>
<dl><dd><dl><dd>Добавлен необязательный модификатор <b>override</b>, который употребляется в объявлении метода, замещающего виртуальный метод родительского класса. Описание замещения с <b>override</b> вызывает проверку на наличие в родительском классе замещаемого метода и на совпадение сигнатур методов.</dd>
<dd>Добавлен также модификатор <b>final</b>, как и в Java, запрещающий дальнейшее замещение помеченного им метода. Также <b>final</b> может быть объявлен класс&#160;— в таком случае от него запрещено наследовать новые классы.</dd></dl></dd></dl>
<ul><li>Добавлена возможность описания <a href="/wiki/%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD" title="Вариативный шаблон">вариативных шаблонов</a>.</li>
<li>Различные синтаксические дополнения.</li></ul>
<dl><dd><dl><dd>Определено ключевое слово для константы&#160;— нулевого указателя: <b>nullptr</b>.</dd>
<dd>Внесены изменения в семантику и, частично, синтаксис перечислений и объединений. Добавлена возможность создавать типобезопасные перечисления, с объединений снят ряд ограничений на структуру.</dd>
<dd>От компилятора требуется правильный лексический разбор текста программы с несколькими закрывающимися угловыми скобками подряд (ранее последовательность «<b>&gt;&gt;</b>» воспринималась однозначно как операция побитового сдвига вправо, поэтому в записи вложенных шаблонных конструкций требовалось обязательно разделять знаки «больше» пробелами или переводами строк).</dd></dl></dd></dl>
<h2><span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC"></span><span class="mw-headline" id="Примеры_программ">Примеры программ</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=26" class="mw-editsection-visualeditor" title="Редактировать раздел «Примеры программ»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=26" title="Редактировать раздел «Примеры программ»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.E2.84.96_1"></span><span class="mw-headline" id="Пример_№_1">Пример №&#160;1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=27" class="mw-editsection-visualeditor" title="Редактировать раздел «Пример № 1»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=27" title="Редактировать раздел «Пример № 1»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Это пример программы <a href="/wiki/Hello,_world!" title="Hello, world!">Hello, world!</a>, которая выводит сообщение, используя стандартную библиотеку, и завершается.
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello, world!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3><span id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.E2.84.96_2"></span><span class="mw-headline" id="Пример_№_2">Пример №&#160;2</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=28" class="mw-editsection-visualeditor" title="Редактировать раздел «Пример № 2»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=28" title="Редактировать раздел «Пример № 2»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Современный C++ позволяет решать простым способом и более сложные задачи. Этот пример демонстрирует, кроме всего прочего, использование контейнеров стандартной библиотеки шаблонов (<a href="/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2" title="Стандартная библиотека шаблонов">STL</a>).
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; // для использования std::cout</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt; // содержит динамический массив</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt; // содержит тип данных словарь</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// импортируем все объявления в пространстве имён &quot;std&quot; в глобальное пространство имён.</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
    <span class="c1">// Объявляем ассоциативный контейнер со строковыми ключами и данными в виде векторов строк</span>
    <span class="n">map</span><span class="o">&lt;</span> <span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">items</span><span class="p">;</span>

    <span class="c1">// Добавим в этот ассоциативный контейнер пару человек и дадим им несколько предметов</span>
    <span class="n">items</span><span class="p">[</span><span class="s">&quot;Anya&quot;</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;scarf&quot;</span><span class="p">);</span>
    <span class="n">items</span><span class="p">[</span><span class="s">&quot;Dmitry&quot;</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;tickets&quot;</span><span class="p">);</span>
    <span class="n">items</span><span class="p">[</span><span class="s">&quot;Anya&quot;</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;puppy&quot;</span><span class="p">);</span>

   <span class="c1">// Переберём все объекты в контейнере</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">person</span> <span class="p">:</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// person - это пара двух объектов: person.first - это его имя,</span>
        <span class="c1">// person.second - это список его предметов (вектор строк)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">person</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; is carrying &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">person</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; items&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>В этом примере для простоты импортируются все имена из пространства имён std. В настоящей же программе так делать не рекомендуется, так как можно столкнуться с коллизией имён. Язык позволяет импортировать отдельные объекты:
</p>
<div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_vector</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>В C++ (как и в C), если выполнение программы доходит до конца функции <code>main()</code>, то это эквивалентно <code>return 0;</code>. Это неверно для любой другой функции кроме <code>main()</code>.
</p>
<h2><span id=".D0.94.D0.BE.D1.81.D1.82.D0.BE.D0.B8.D0.BD.D1.81.D1.82.D0.B2.D0.B0_.D0.B8_.D0.BD.D0.B5.D0.B4.D0.BE.D1.81.D1.82.D0.B0.D1.82.D0.BA.D0.B8"></span><span class="mw-headline" id="Достоинства_и_недостатки">Достоинства и недостатки</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=29" class="mw-editsection-visualeditor" title="Редактировать раздел «Достоинства и недостатки»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=29" title="Редактировать раздел «Достоинства и недостатки»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span id=".D0.94.D0.BE.D1.81.D1.82.D0.BE.D0.B8.D0.BD.D1.81.D1.82.D0.B2.D0.B0"></span><span class="mw-headline" id="Достоинства">Достоинства</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=30" class="mw-editsection-visualeditor" title="Редактировать раздел «Достоинства»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=30" title="Редактировать раздел «Достоинства»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++ содержит средства разработки программ контролируемой эффективности для широкого спектра задач, от низкоуровневых утилит и драйверов до весьма сложных программных комплексов. В частности:
</p>
<ul><li>Высокая совместимость с языком Си&#160;: код на Си может быть с минимальными переделками скомпилирован компилятором C++. Внешнеязыковой интерфейс является прозрачным, так что библиотеки на Си могут вызываться из C++ без дополнительных затрат, и более того&#160;— при определённых ограничениях код на C++ может экспортироваться внешне не отличимо от кода на Си (конструкция <code>extern&#160;"C"</code>).</li>
<li>Как следствие предыдущего пункта&#160;— вычислительная производительность. Язык спроектирован так, чтобы дать программисту максимальный контроль над всеми аспектами структуры и порядка исполнения программы. Один из базовых принципов C++&#160;— «<i>не платишь за то, что не используешь</i>» (см. <a href="#Философия_C++">Философия C++</a>)&#160;— то есть ни одна из языковых возможностей, приводящая к дополнительным накладным расходам, не является обязательной для использования. Имеется возможность работы с памятью на низком уровне.</li>
<li>Поддержка различных стилей программирования: традиционное императивное программирование (структурное, объектно-ориентированное), <a href="/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Обобщённое программирование">обобщённое программирование</a>, <a href="/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Функциональное программирование">функциональное программирование</a>, <a href="/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Метапрограммирование">порождающее метапрограммирование</a>.</li>
<li>Автоматический вызов деструкторов объектов в адекватном порядке (обратном вызову конструкторов) упрощает и повышает надёжность управления памятью и другими ресурсами (открытыми файлами, сетевыми соединениями, соединениями с базами данных и&#160;т.&#160;п.).</li>
<li><a href="#Перегрузка_операторов">Перегрузка операторов</a> позволяет кратко и ёмко записывать выражения над пользовательскими типами в естественной алгебраической форме.</li>
<li>Имеется возможность управления константностью объектов (модификаторы <code>const</code>, <code>mutable</code>, <code>volatile</code>). Использование константных объектов повышает надёжность и служит подсказкой для оптимизации. Перегрузка функций-членов по признаку константности позволяет определять выбор метода в зависимости цели вызова (константный для чтения, неконстантный для изменения). Объявление <code>mutable</code> позволяет сохранять логическую константность при виде извне кода, использующего кэши и <a href="/wiki/%D0%9B%D0%B5%D0%BD%D0%B8%D0%B2%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F" title="Ленивые вычисления">ленивые вычисления</a>.</li>
<li><a href="/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_C%2B%2B" title="Шаблоны C++">Шаблоны C++</a> дают возможность построения <a href="/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Обобщённое программирование">обобщённых контейнеров и алгоритмов</a> для разных типов данных. Попутно шаблоны дают возможность производить вычисления на этапе компиляции.</li>
<li>Возможность встраивания <a href="/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" class="mw-redirect" title="Предметно-ориентированный язык программирования">предметно-ориентированных языков программирования</a> в основной код. Такой подход использует, например библиотека <code>Boost.Spirit</code>, позволяющая задавать <a href="/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0" title="Расширенная форма Бэкуса — Наура">EBNF</a>-грамматику <a href="/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7" title="Синтаксический анализ">парсеров</a> прямо в коде C++.</li>
<li>Доступность. Для C++ существует огромное количество учебной литературы, переведённой на всевозможные языки. Язык имеет высокий порог вхождения, но среди всех языков такого рода обладает наиболее широкими возможностями.</li></ul>
<h3><span id=".D0.9D.D0.B5.D0.B4.D0.BE.D1.81.D1.82.D0.B0.D1.82.D0.BA.D0.B8"></span><span class="mw-headline" id="Недостатки">Недостатки</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=31" class="mw-editsection-visualeditor" title="Редактировать раздел «Недостатки»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=31" title="Редактировать раздел «Недостатки»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>К числу обычно упоминаемых недостатков языка можно отнести:
</p>
<ul><li>Отсутствие системы модулей. C++ унаследовал от Си подключение заголовочных файлов с помощью препроцессора. Это вынуждает дублировать описания объектов, порождает неочевидные требования к коду (см. <i><a href="/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F" title="Правило одного определения">правило одного определения</a></i>) и увеличивает объём компилируемого текста, а значит и время компиляции.</li>
<li>Наличие более чем одного механизма для выполнения одних и тех же задач, что усложняет язык и приводит к неоптимальному и небезопасному кодированию.</li>
<li>Унаследованные от Си опасные и провоцирующие ошибки возможности (макроопределения, адресная арифметика, неявное приведение типов, возможность прямого управления распределением памяти).</li>
<li>Отсутствие встроенных механизмов статической валидации времени жизни объектов, приводящее к внезапному краху программ из-за обращения к уничтоженной переменной, или из-за неправильной многопоточной работы с объектами.</li>
<li>Шаблоны порождают объёмный и не всегда оптимальный код. Частичное определение шаблонов усложняет как сам язык, так и программы, где оно используется.</li>
<li>Множественное (в том числе виртуальное) наследование приводит к созданию громоздких иерархий классов, которые при любом изменении требований к программе могут потребовать серьёзного пересмотра.</li>
<li>Сложный синтаксис и объёмная спецификация языка затрудняют его изучение.</li>
<li>Язык не поощряет создание надёжного, легко читаемого и удобного в сопровождении кода, вместо этого зачастую предлагая выбор между короткими и простыми, но опасными средствами, унаследованными от Си, и новыми, объёмными и сложными, но более безопасными механизмами.</li>
<li>Сложная и постоянно разрастающаяся стандартная библиотека, затрудняющая изучение языка.</li></ul>
<h2><span id=".D0.9A.D1.80.D0.B8.D1.82.D0.B8.D0.BA.D0.B0"></span><span class="mw-headline" id="Критика">Критика</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=32" class="mw-editsection-visualeditor" title="Редактировать раздел «Критика»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=32" title="Редактировать раздел «Критика»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<table class="plainlinks metadata ambox ambox-style" role="presentation"><tbody><tr><td class="mbox-image"><div style="width:52px"><a href="/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Broom_icon.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Broom_icon.svg/40px-Broom_icon.svg.png" decoding="async" width="40" height="40" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Broom_icon.svg/60px-Broom_icon.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Broom_icon.svg/80px-Broom_icon.svg.png 2x" data-file-width="400" data-file-height="400" /></a></div></td><td class="mbox-text"><div class="mbox-text-div"><b>Содержимое этой статьи или раздела нуждается в чистке.</b></div><div class="mbox-textsmall-div hide-when-compact" style="font-size:85%">Текст содержит много <a href="/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F:%D0%97%D0%BD%D0%B0%D1%87%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C_%D1%84%D0%B0%D0%BA%D1%82%D0%B0" title="Википедия:Значимость факта">маловажных</a>, <a href="/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F:%D0%A7%D0%B5%D0%BC_%D0%BD%D0%B5_%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F_%D0%92%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F" title="Википедия:Чем не является Википедия">неэнциклопедичных</a> или устаревших подробностей.  Пожалуйста, улучшите статью в соответствии с <a href="/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F:%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%B8_%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D0%BD%D0%B8%D1%8F" title="Википедия:Правила и указания">правилами написания статей</a>.</div></td></tr></tbody></table>
<h3><span id=".D0.9E_.D0.BA.D1.80.D0.B8.D1.82.D0.B8.D0.BA.D0.B5_C.2B.2B_.D0.B2_.D1.86.D0.B5.D0.BB.D0.BE.D0.BC"></span><span class="mw-headline" id="О_критике_C++_в_целом">О критике C++ в целом</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=33" class="mw-editsection-visualeditor" title="Редактировать раздел «О критике C++ в целом»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=33" title="Редактировать раздел «О критике C++ в целом»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Чаще всего критики не противопоставляют C++ какой-либо другой конкретный язык, а утверждают, что отказ от использования единственного языка, имеющего многочисленные недостатки, в пользу декомпозиции проекта на подзадачи, решаемые на различных, наиболее подходящих для них, языках, делает разработку существенно менее трудоёмкой при одновременном повышении показателей <a href="/wiki/%D0%9A%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F" title="Качество программного обеспечения">качества программирования</a><sup id="cite_ref-languageorient_23-0" class="reference"><a href="#cite_note-languageorient-23">&#91;21&#93;</a></sup><sup id="cite_ref-Hudak_DSL_24-0" class="reference"><a href="#cite_note-Hudak_DSL-24">&#91;22&#93;</a></sup>. По этой же причине критикуется сохранение совместимости с Си: если часть задачи требует низкоуровневых возможностей, разумнее выделить эту часть в отдельную подсистему и написать её на Си.
</p><p>В свою очередь, сторонники C++ заявляют, что устранение технических и организационных проблем межъязыкового взаимодействия за счёт использование одного универсального языка вместо нескольких специализированных важнее, чем потери от несовершенства этого универсального языка, то есть сама широта набора возможностей C++ является оправданием недостатков каждой отдельной возможности; в том числе недостатки, унаследованные от Си, оправданы преимуществами совместимости (см. <a href="#Философия_C++">выше</a>). 
</p><p>Таким образом, одни и те же свойства C++: объём, сложность, <a href="/wiki/%D0%AD%D0%BA%D0%BB%D0%B5%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C" class="mw-redirect mw-disambig" title="Эклектичность">эклектичность</a> и отсутствие конкретной целевой ниши применения рассматривается сторонниками как «<i>главное достоинство</i>», а критиками&#160;— как «<i>главный недостаток</i>».
</p>
<h3><span id=".D0.A1.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81_.D0.B0.D0.BB.D1.8C.D1.82.D0.B5.D1.80.D0.BD.D0.B0.D1.82.D0.B8.D0.B2.D0.BD.D1.8B.D0.BC.D0.B8_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0.D0.BC.D0.B8"></span><span class="mw-headline" id="Сравнение_с_альтернативными_языками">Сравнение с альтернативными языками</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=34" class="mw-editsection-visualeditor" title="Редактировать раздел «Сравнение с альтернативными языками»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=34" title="Редактировать раздел «Сравнение с альтернативными языками»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Известно несколько исследований, в которых была сделана попытка более или менее объективно сравнить несколько языков программирования, одним из которых является C++. В частности:
</p>
<ul><li>В работе «Haskell vs. Ada vs. C++ vs. Awk vs. …» Пауля Худака и Марка Джонса<sup id="cite_ref-haskell_25-0" class="reference"><a href="#cite_note-haskell-25">&#91;23&#93;</a></sup> сравнивается ряд императивных и функциональных языков в решении модельной задачи быстрого прототипирования ГИС-системы военного назначения.</li>
<li>В работе Лутца Прехельта<sup id="cite_ref-perhelt_26-0" class="reference"><a href="#cite_note-perhelt-26">&#91;24&#93;</a></sup> рассмотрено семь языков (C, C++, Java, Perl, Python, Rexx и Tcl) в задаче написания простой программы преобразования телефонных номеров в слова по определённым правилам.</li>
<li>В статье Дэвида Велера «Ada, C, C++, and Java vs. The Steelman»<sup id="cite_ref-steelman_27-0" class="reference"><a href="#cite_note-steelman-27">&#91;25&#93;</a></sup> приведено сопоставление языков Ада, C++, Си, Java с документом «<span class="iw plainlinks" data-title="Требования Стилмена к языкам программирования" data-lang="en" data-lang-name="англ."><a href="/w/index.php?title=%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D1%82%D0%B8%D0%BB%D0%BC%D0%B5%D0%BD%D0%B0_%D0%BA_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0%D0%BC_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F&amp;action=edit&amp;redlink=1" class="new" title="Требования Стилмена к языкам программирования (страница отсутствует)">Steelman</a><sup class="iw&#95;_note noprint" style="font-style:normal; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Steelman_language_requirements" class="extiw" title="en:Steelman language requirements"><span class="iw&#95;_tooltip" title="Steelman language requirements — версия статьи «Требования Стилмена к языкам программирования» на английском языке">[en]</span></a></sup></span>»&#160;— списком требований к языку для военных разработок встроенных систем, который был выработан комитетом по языку высокого уровня Министерства обороны США в 1978 году. Хотя этот документ сильно устарел и не учитывает многих существенных свойств современных языков, сравнение демонстрирует, что C++ по набору востребованных в отрасли возможностей не так уж сильно отличается от языков, которые можно считать его реальными конкурентами.</li></ul>
<h4><span id="C.2B.2B_.D0.B8_.D0.90.D0.B4.D0.B0"></span><span class="mw-headline" id="C++_и_Ада">C++ и Ада</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=35" class="mw-editsection-visualeditor" title="Редактировать раздел «C++ и Ада»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=35" title="Редактировать раздел «C++ и Ада»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p><a href="/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%90%D0%B4%D0%B0" class="mw-redirect" title="Язык Ада">Язык Ада</a> близок к C++ по набору возможностей и по сферам применения: это компилируемый структурный язык с Симула-подобным объектно-ориентированным дополнением (та же модель «Алгол с классами», что и в C++), статической типизацией, средствами обобщённого программирования, предназначенный для разработки крупных и сложных программных систем. В то же время он принципиально отличается по идеологии: в отличие от C++, Ада строилась на основе предварительно тщательно проработанных условий производителей сложного ПО с повышенными требованиями к надёжности, что наложило отпечаток на синтаксис и семантику языка.
</p><p>Прямых сравнений эффективности кодирования на Аде и C++ немного. В упомянутой выше статье<sup id="cite_ref-haskell_25-1" class="reference"><a href="#cite_note-haskell-25">&#91;23&#93;</a></sup> решение модельной задачи на Аде привело к получению кода примерно на 30&#160;% меньшего по объёму (в строках), чем на C++. Сравнение свойств самих языков приводится во многих источниках, например, в статье Джима Роджерса на AdaHome<sup id="cite_ref-rogers_28-0" class="reference"><a href="#cite_note-rogers-28">&#91;26&#93;</a></sup> содержится перечисление более 50 пунктов различий свойств этих языков, большая часть которых&#160;— в пользу Ады (больше возможностей, более гибкое поведение, меньше вероятность ошибок). Хотя многие утверждения сторонников Ады спорны, а часть из них явно устарела, в целом можно заключить:
</p>
<ul><li>Синтаксис Ады гораздо строже, чем C++. Язык требует соблюдения дисциплины программирования, не поощряет «программистские трюки», стимулирует написание простого, логичного и легко понимаемого кода, удобного в сопровождении.</li>
<li>В отличие от C++, Ада максимально типобезопасна. Развитая система типов позволяет, при соблюдении дисциплины их объявления и использования, максимально полно статически контролировать корректность использования данных и защищает от случайных ошибок. Автоматические преобразования типов сведены к минимуму.</li>
<li>Указатели в Аде контролируются гораздо более строго, чем в C++, а адресная арифметика доступна только через отдельную системную библиотеку.</li>
<li>Настраиваемые модули Ады по возможностям аналогичны шаблонам C++, но обеспечивают лучший контроль.</li>
<li>Ада имеет встроенную в язык модульность и стандартизованную систему раздельной компиляции, тогда как C++ применяет включение текстовых файлов и внешние средства управления компиляцией и сборкой.</li>
<li>Встроенная многозадачность Ады включает параллельные задачи и механизм их коммуникации (входы, рандеву, оператор <code>select</code>). В C++ всё это реализуется только на уровне библиотек.</li>
<li>Ада строго стандартизована, за счёт чего обеспечивает лучшую переносимость.</li></ul>
<p>В статье Стефена Цейгера из <a href="/wiki/Rational_Software_Corporation" class="mw-redirect" title="Rational Software Corporation">Rational Software Corporation</a><sup id="cite_ref-29" class="reference"><a href="#cite_note-29">&#91;27&#93;</a></sup>, утверждается, что в целом разработка на Аде обходится на 60&#160;% дешевле, и приводит к получению кода, имеющего в 9 раз меньше дефектов, чем на Си. Хотя эти результаты не могут быть прямо перенесены на C++, но всё же представляют интерес с учётом того, что многие недостатки C++ унаследованы от Си.
</p>
<h4><span id="C.2B.2B_.D0.B8_Java"></span><span class="mw-headline" id="C++_и_Java">C++ и Java</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=36" class="mw-editsection-visualeditor" title="Редактировать раздел «C++ и Java»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=36" title="Редактировать раздел «C++ и Java»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Java не может считаться в полной мере заменой C++, она создана как безопасный язык с низким порогом вхождения для разработки прикладных пользовательских приложений с высокими показателями портируемости<sup id="cite_ref-30" class="reference"><a href="#cite_note-30">&#91;28&#93;</a></sup> и принципиально непригодна для некоторых типов приложений, которые разрабатываются на C++. Однако в пределах своей области Java составляет вполне реальную конкуренцию C++. В качестве преимуществ Java обычно называют:
</p>
<ul><li>Безопасность: отсутствие поддержки указателей и адресной арифметики, автоматическое управление памятью со сборкой мусора, встроенные средства, защищающие от распространённых ошибок программ C++, таких как переполнение буфера или выход за границы массива.</li>
<li>Наличие разработанной системы модулей и раздельной компиляции, значительно более быстрой и менее подверженной ошибкам, чем препроцессор и ручная сборка C++.</li>
<li>Полная стандартизация и исполнение в виртуальной машине, развитое окружение, включающие библиотеки для графики, интерфейса пользователя, доступа к базам данных прочих типовых задач, как следствие — реальная многоплатформенность.</li>
<li>Встроенная многопоточность.</li>
<li>Объектная подсистема Java в значительно более высокой степени, чем C++, отвечает фундаментальному принципу ООП «<i>всё — объект</i>». Интерфейсы позволяют обеспечить большинство преимуществ множественного наследования, не вызывая его негативных эффектов.</li>
<li>Рефлексия значительно более развита, чем в C++ и позволяет реально определять и изменять структуру объектов во время работы программы.</li></ul>
<p>В то же время использование сборщика мусора и виртуальной машины создают трудно преодолимые ограничения. Программы на Java, как правило, медленнее, требуют значительно больше памяти, к тому же виртуальная машина изолирует программу от операционной системы, делая невозможным низкоуровневое программирование. Также можно заметить, что эмпирическое исследование<sup id="cite_ref-perhelt_26-1" class="reference"><a href="#cite_note-perhelt-26">&#91;24&#93;</a></sup> не обнаружило существенной разницы в скорости разработки на C++ и на Java.
</p>
<h4><span id="C.2B.2B_.D0.B8_C"></span><span class="mw-headline" id="C++_и_C">C++ и C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=37" class="mw-editsection-visualeditor" title="Редактировать раздел «C++ и C»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=37" title="Редактировать раздел «C++ и C»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Оригинальный Си продолжает развиваться, на нём разрабатываются многие масштабные проекты: он является основным языком разработки операционных систем, на нём написаны игровые движки многих динамических игр и большое число прикладных приложений. Ряд специалистов утверждает, что замена Си на C++ не повышает эффективность разработки, но приводит к ненужному усложнению проекта, снижению надёжности и увеличению затрат на сопровождение. В частности:
</p>
<ul><li>По мнению Линуса Торвальдса, «C++ провоцирует на написание … значительного объёма кода, не имеющего принципиального значения с точки зрения функциональности программы»<sup id="cite_ref-torvalds_31-0" class="reference"><a href="#cite_note-torvalds-31">&#91;мнения 3&#93;</a></sup>.</li>
<li>Поддержка ООП, шаблоны и STL не являются решающим преимуществом C++, так как всё, для чего они применяются, реализуемо и средствами Си. При этом устраняется раздувание кода, а некоторое усложнение, которое к тому же далеко не обязательно, компенсируется большей гибкостью, более простым тестированием, лучшими показателями производительности.</li>
<li>Автоматизация доступа к памяти в C++ увеличивает затраты памяти и замедляет работу программ.</li>
<li>Использование исключений C++ вынуждает следовать <a href="/wiki/RAII" class="mw-redirect" title="RAII">RAII</a>, приводит к росту исполняемых файлов, замедлению программ. Дополнительные трудности возникают в параллельных и распределённых программах. Показательно, что стандарт кодирования на C++ компании Google прямо запрещает использование исключений.<sup id="cite_ref-googlesg_32-0" class="reference"><a href="#cite_note-googlesg-32">&#91;29&#93;</a></sup></li>
<li>Код на C++ сложнее для понимания и тестирования, его отладка затрудняется использованием сложных иерархий классов с наследованием поведения и шаблонов. К тому же в средах программирования на C++ больше ошибок, как в компиляторах, так и в библиотеках.</li>
<li>Многие детали поведения кода стандартом C++ не специфицированы, что ухудшает переносимость и может являться причиной трудно обнаруживаемых ошибок.</li>
<li>Квалифицированных программистов на Си существенно больше, чем на C++.</li></ul>
<p>Нет убедительных данных о преимуществе C++ перед Си ни по производительности программистов, ни по свойствам программ. Хотя есть исследования<sup id="cite_ref-33" class="reference"><a href="#cite_note-33">&#91;30&#93;</a></sup> утверждающие, что программисты на Си тратят 30&#160;%&#160;— 40&#160;% общего времени разработки (не считая отладки) на управление памятью, при сопоставлении общей производительности разработчиков<sup id="cite_ref-haskell_25-2" class="reference"><a href="#cite_note-haskell-25">&#91;23&#93;</a></sup> Си и C++ оказываются близки.
</p><p>В низкоуровневом программировании значительная часть новых возможностей C++ оказывается неприменимой из-за увеличения накладных расходов: виртуальные функции требуют динамического вычисления реального адреса (RVA), шаблоны приводят к раздуванию кода и ухудшению возможностей оптимизации, библиотека времени исполнения (RTL) очень велика, а отказ от неё лишает большинства возможностей C++ (хотя бы из-за недоступности операций <code>new/delete</code>). В результате программисту придётся ограничиться функционалом, унаследованным от Си, что делает бессмысленным применение C++:
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r106630606"/>
</p>
<blockquote class="ts-Начало_цитаты-quote"><p>
… единственный способ иметь хороший, эффективный, низкоуровневый и портируемый C++ сводится к тому, чтобы ограничиться всеми теми вещами, которые элементарно доступны в Си. А ограничение проекта рамками Си будет означать, что люди его не выкинут, и что будет доступно множество программистов, действительно хорошо понимающих низкоуровневые особенности и не отказывающихся от них из-за идиотской ерунды про «объектные модели».<br />… когда эффективность является первостепенным требованием, «преимущества» C++ будут огромной ошибкой.<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r104610272"/></p><div class="ts-Конец_цитаты-source">— <cite><a href="/wiki/%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81,_%D0%9B%D0%B8%D0%BD%D1%83%D1%81" title="Торвальдс, Линус">Линус Торвальдс</a>,<sup id="cite_ref-autogenerated1_34-0" class="reference"><a href="#cite_note-autogenerated1-34">&#91;31&#93;</a></sup></cite></div></blockquote>
<h4><span id="C.2B.2B_.D0.B8_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.BE.D0.BD.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B8_.D1.81.D0.BA.D1.80.D0.B8.D0.BF.D1.82.D0.BE.D0.B2.D1.8B.D0.B5_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B8"></span><span class="mw-headline" id="C++_и_функциональные_и_скриптовые_языки">C++ и функциональные и скриптовые языки</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=38" class="mw-editsection-visualeditor" title="Редактировать раздел «C++ и функциональные и скриптовые языки»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=38" title="Редактировать раздел «C++ и функциональные и скриптовые языки»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>В эксперименте<sup id="cite_ref-haskell_25-3" class="reference"><a href="#cite_note-haskell-25">&#91;23&#93;</a></sup> скриптовые и функциональные языки, в частности, <a href="/wiki/Haskell" title="Haskell">Haskell</a>, показали 2-3 кратный выигрыш во времени программирования и объёме кода по сравнению с программами на C++. С другой стороны, программы на C++ оказались во столько же раз быстрее. Авторы признают, что полученные ими данные не составляют репрезентативной выборки и воздерживаются от категоричных выводов.
</p><p>В исследовании Лутца Прехельта<sup id="cite_ref-perhelt_26-2" class="reference"><a href="#cite_note-perhelt-26">&#91;24&#93;</a></sup> по результатам обработки около 80 решений, написанных добровольцами, получены, в частности, следующие выводы:
</p>
<ul><li>Perl, Python, Rexx, Tcl обеспечили скорость разработки вдвое больше, чем C, C++ и Java, причём полученный код был также вдвое короче.</li>
<li>Программы на скриптовых языках потребляли примерно вдвое больше памяти, чем C/C++</li></ul>
<h3><span id=".D0.9A.D1.80.D0.B8.D1.82.D0.B8.D0.BA.D0.B0_.D0.BE.D1.82.D0.B4.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D1.85_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BE.D0.B2_.D0.B8_.D0.BA.D0.BE.D0.BD.D1.86.D0.B5.D0.BF.D1.86.D0.B8.D0.B9"></span><span class="mw-headline" id="Критика_отдельных_элементов_и_концепций">Критика отдельных элементов и концепций</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=39" class="mw-editsection-visualeditor" title="Редактировать раздел «Критика отдельных элементов и концепций»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=39" title="Редактировать раздел «Критика отдельных элементов и концепций»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D1.8C_.D0.B7.D0.B0_.D0.BF.D0.BE.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5.D0.BC"></span><span class="mw-headline" id="Контроль_за_поведением">Контроль за поведением</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=40" class="mw-editsection-visualeditor" title="Редактировать раздел «Контроль за поведением»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=40" title="Редактировать раздел «Контроль за поведением»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Идеология языка смешивает «контроль за <i>поведением</i>» с «контролем за <i>эффективностью</i>», то есть предполагает, что обеспечение полного контроля программиста за всеми аспектами исполнения программы на довольно низком уровне является необходимым и достаточным условием достижения высокой эффективности кода. В действительности для сколько-нибудь крупных программ это неверно, так как их сложность настолько высока, что осознание её в полном объёме на низком уровне превышает возможности человека. Принцип «<i>не платишь за то, что не используешь</i>»<style data-mw-deduplicate="TemplateStyles:r104609042">.mw-parser-output .ts-Переход img{margin-left:.285714em}</style><span class="ts-Переход noprint" title="#Философия C++"><sup><a href="#Философия_C++">[⇨]</a></sup></span>, заявленный как средство обеспечения эффективности, на практике приводит к отказу от <a href="/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#Параметрический_полиморфизм" class="mw-redirect" title="Полиморфизм (программирование)">параметрического полиморфизма</a> и необходимости явного описания различного поведения для различных ситуаций под единым идентификатором (<a href="/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80_%D0%B8_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9" title="Перегрузка процедур и функций">перегрузки функций</a>), с ручной оптимизацией кода для каждого такого варианта, что вызывает значительное увеличение объёма и сложности кода, усугубляя проблемы управления сложностью. Возложение на программиста низкоуровневой оптимизации, которую качественный компилятор <a href="/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" class="mw-redirect" title="Предметно-ориентированный язык программирования">предметно-ориентированного</a> языка способен выполнить заведомо более эффективно, приводит лишь к росту трудоёмкости программирования и снижению показателей понимаемости и тестируемости кода. Таким образом, принцип «не платить за то, что не используется» в действительности не даёт желаемых выгод в эффективности, но негативно сказывается на качестве.
</p>
<h4><span id=".D0.9A.D0.BE.D0.BC.D0.BF.D0.BE.D0.BD.D0.B5.D0.BD.D1.82.D0.BD.D0.BE.D0.B5_.D0.B8_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D0.BD.D0.BE-.D0.BE.D1.80.D0.B8.D0.B5.D0.BD.D1.82.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B5_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5"></span><span class="mw-headline" id="Компонентное_и_объектно-ориентированное_программирование">Компонентное и объектно-ориентированное программирование</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=41" class="mw-editsection-visualeditor" title="Редактировать раздел «Компонентное и объектно-ориентированное программирование»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=41" title="Редактировать раздел «Компонентное и объектно-ориентированное программирование»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>По мнению <a href="/wiki/%D0%9A%D1%8D%D0%B9,_%D0%90%D0%BB%D0%B0%D0%BD_%D0%9A%D1%91%D1%80%D1%82%D0%B8%D1%81" title="Кэй, Алан Кёртис">Алана Кэя</a>, объектная модель «<a href="/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D0%BB" title="Алгол">Алгол</a> с классами», использованная в C++, уступает модели «всё&#160;— объект»<sup id="cite_ref-alankay_35-0" class="reference"><a href="#cite_note-alankay-35">&#91;32&#93;</a></sup>, используемой в <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, по общем объёму возможностей, показателям <a href="/wiki/%D0%9F%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%BD%D0%BE%D0%B5_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%B4%D0%B0" title="Повторное использование кода">повторного использования кода</a>, понимаемости, модифицируемости и тестируемости.
</p><p>Модель наследования C++ сложна, трудна в реализации и при этом провоцирует создание сложных иерархий с неестественными отношениями между классами (например, наследование вместо вложения). Результатом становится создание <a href="/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Зацепление (программирование)">сильно зацепленных</a> классов с нечётко разделённым функционалом. Например, в <sup id="cite_ref-_213d6d8b80a935d7_36-0" class="reference"><a href="#cite_note-_213d6d8b80a935d7-36">&#91;33&#93;</a></sup> приводится учебно-рекомендательный пример реализации класса «список» как подкласса от класса «элемент списка», который, в свою очередь, содержит функции доступа к другим элементам списка. Такое отношение типов является абсурдом с точки зрения математики и невоспроизводимо на более строгих языках. Идеология некоторых библиотек требует ручного приведения типов вверх и вниз по иерархии классов (<code>static_cast</code> и <code>dynamic_cast</code>), что нарушает <a href="/wiki/%D0%A2%D0%B8%D0%BF%D0%BE%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C" title="Типобезопасность">типобезопасность</a> языка. Высокая <a href="/wiki/%D0%92%D1%8F%D0%B7%D0%BA%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Вязкость (программирование)">вязкость</a> решений на C++ может требовать повторной разработки значительных частей проекта при необходимости внесения минимальных изменений на поздних стадиях разработки. Яркий пример подобных проблем можно найти в<sup id="cite_ref-languageorient_23-1" class="reference"><a href="#cite_note-languageorient-23">&#91;21&#93;</a></sup>
</p><p>Как отмечает Ян Джойнер<sup id="cite_ref-Joyner_37-0" class="reference"><a href="#cite_note-Joyner-37">&#91;34&#93;</a></sup>, C++ ошибочно отождествляет инкапсуляцию (то есть помещение данных внутрь объектов и отделение реализации от интерфейса) и сокрытие реализации. Это усложняет доступ к данным класса и требует реализовывать его интерфейс практически исключительно через функции доступа (что, в свою очередь, увеличивает объём кода и усложняет его).
</p><p>Совпадение типов в C++ определяется на уровне идентификаторов, а не сигнатур. Это затрудняет реализацию абстрактных механизмов работы с данными, так как делает невозможной подмену компонентов, основанную на совпадении их интерфейсной функциональности. В результате для включения в систему новой функциональности, реализованной на уровне библиотек, оказывается необходимо вручную модифицировать уже имеющийся код для адаптации его под новый модуль<sup id="cite_ref-Paulson_38-0" class="reference"><a href="#cite_note-Paulson-38">&#91;35&#93;</a></sup>. Как отмечает <a href="/wiki/%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81,_%D0%9B%D0%B8%D0%BD%D1%83%D1%81" title="Торвальдс, Линус">Линус Торвальдс</a><sup id="cite_ref-autogenerated1_34-1" class="reference"><a href="#cite_note-autogenerated1-34">&#91;31&#93;</a></sup>, в C++ «код кажется абстрактным лишь до тех пор, пока не возникает необходимость его изменить».
</p><p>Критика C++ с позиций только ООП (без сравнения методологий проектирования) с описанием вреда от влияния C++ на другие языки приведена в работе<sup id="cite_ref-Joyner_37-1" class="reference"><a href="#cite_note-Joyner-37">&#91;34&#93;</a></sup>.
</p>
<h4><span id=".D0.9C.D0.B5.D1.82.D0.B0.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5"></span><span class="mw-headline" id="Метапрограммирование">Метапрограммирование</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=42" class="mw-editsection-visualeditor" title="Редактировать раздел «Метапрограммирование»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=42" title="Редактировать раздел «Метапрограммирование»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Порождающее метапрограммирование C++ основано на шаблонах и <a href="/wiki/%D0%9F%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80" title="Препроцессор">препроцессоре</a>, оно трудоёмко и ограничено по возможностям. Система шаблонов C++ фактически является вариантом примитивного <a href="/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" class="mw-redirect" title="Функциональный язык программирования">функционального языка программирования</a>, исполняемого на этапе компиляции. Этот язык почти не пересекается с самим C++, из-за чего потенциал роста сложности абстракций оказывается ограниченным. Программы, использующие шаблоны C++, имеют крайне низкие показатели понимаемости и тестируемости, а само разворачивание шаблонов порождает неэффективный код, так как язык шаблонов не предоставляет никаких средств для оптимизации (см. также раздел <a href="#Вычислительная_эффективность">#Вычислительная эффективность</a>). Встраиваемые предметно-специфичные языки, реализуемые таким образом, всё равно требуют знания самого C++, что не обеспечивает полноценного разделения труда. Таким образом, возможности C++ по расширению возможностей самого C++ весьма ограничены.<sup id="cite_ref-39" class="reference"><a href="#cite_note-39">&#91;36&#93;</a></sup><sup id="cite_ref-40" class="reference"><a href="#cite_note-40">&#91;37&#93;</a></sup>
</p>
<h4><span id=".D0.9A.D1.80.D0.BE.D1.81.D1.81.D0.BF.D0.BB.D0.B0.D1.82.D1.84.D0.BE.D1.80.D0.BC.D0.B5.D0.BD.D0.BD.D0.BE.D1.81.D1.82.D1.8C"></span><span class="mw-headline" id="Кроссплатформенность">Кроссплатформенность</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=43" class="mw-editsection-visualeditor" title="Редактировать раздел «Кроссплатформенность»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=43" title="Редактировать раздел «Кроссплатформенность»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Для написания портируемого кода на C++ требуется огромное мастерство и опыт, и «небрежные» коды на C++ с высокой вероятностью могут оказаться непортируемыми<sup id="cite_ref-XXtraps64bit_41-0" class="reference"><a href="#cite_note-XXtraps64bit-41">&#91;38&#93;</a></sup>. По мнению <a href="/wiki/%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81,_%D0%9B%D0%B8%D0%BD%D1%83%D1%81" title="Торвальдс, Линус">Линуса Торвальдса</a>, для обеспечения на C++ портируемости, аналогичной Си, программист должен ограничиться возможностями C++, унаследованными от Си<sup id="cite_ref-autogenerated1_34-2" class="reference"><a href="#cite_note-autogenerated1-34">&#91;31&#93;</a></sup>. Стандарт содержит множество элементов, определённых как «implementation-defined» (например, размер указателей на методы классов в различных компиляторах варьируется в диапазоне от 4 до 20 байт<sup id="cite_ref-42" class="reference"><a href="#cite_note-42">&#91;39&#93;</a></sup>), что ухудшает портируемость программ с их использованием.
</p><p>Директивный характер <a href="/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" title="Стандартизация">стандартизации</a> языка, неполная обратная совместимость и противоречивость требований разных версий стандарта приводят к проблемам в переносе программ между различными компиляторами и даже версиями одних и тех же компиляторов.
</p>
<h3><span id=".D0.9E.D1.82.D1.81.D1.83.D1.82.D1.81.D1.82.D0.B2.D0.B8.D0.B5_.D0.B2.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B5.D0.B9"></span><span class="mw-headline" id="Отсутствие_возможностей">Отсутствие возможностей</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=44" class="mw-editsection-visualeditor" title="Редактировать раздел «Отсутствие возможностей»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=44" title="Редактировать раздел «Отсутствие возможностей»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<dl><dt>Рефлексивное метапрограммирование</dt>
<dd><a href="/wiki/%D0%9E%D1%82%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" class="mw-redirect" title="Отражение (программирование)">Интроспекция</a> в C++ реализована отдельно от основной системы типов, что делает её практически бесполезной. Наибольшее, что можно получить&#160;— параметризацию поведения на заранее известном наборе вариантов. Это препятствует применению C++ в большинстве подходов к реализации <a href="/wiki/%D0%98%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82" title="Искусственный интеллект">Искусственного Интеллекта</a>.</dd></dl>
<dl><dt>Функциональное программирование</dt>
<dd>Явная поддержка функционального программирования присутствует только в стандарте <a href="/wiki/C%2B%2B0x" class="mw-redirect" title="C++0x">C++0x</a>, ранее пробел устранялся библиотеками (<a href="/wiki/Loki" title="Loki">Loki</a>, <a href="/wiki/Boost" title="Boost">Boost</a>), использующими язык шаблонов, но их качество значительно уступают решениям, встроенным в функциональные языки,<sup id="cite_ref-43" class="reference"><a href="#cite_note-43">&#91;пояснения 1&#93;</a></sup> как и качеству реализаций возможностей C++ (таких как ООП) посредством функциональных языков. Реализованные в C++ возможности ФП не дают возможности применения присущих функциональному программированию оптимизационных методик<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r104609042"/><span class="ts-Переход noprint" title="#Вычислительная эффективность"><sup><a href="#Вычислительная_эффективность">[⇨]</a></sup></span>, а ограничивается вызовами функциональных библиотек и реализацией отдельных методов. Это практически не даёт преимуществ в проектировании программ (см. <a href="/wiki/%D0%A1%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D1%80%D0%B8_%E2%80%94_%D0%A5%D0%BE%D0%B2%D0%B0%D1%80%D0%B4%D0%B0" title="Соответствие Карри — Ховарда">Соответствие Карри — Ховарда</a>).</dd></dl>
<h3><span id=".D0.98.D0.B7.D0.B1.D1.8B.D1.82.D0.BE.D1.87.D0.BD.D1.8B.D0.B5_.D0.B8_.D0.BE.D0.BF.D0.B0.D1.81.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8"></span><span class="mw-headline" id="Избыточные_и_опасные_возможности">Избыточные и опасные возможности</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=45" class="mw-editsection-visualeditor" title="Редактировать раздел «Избыточные и опасные возможности»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=45" title="Редактировать раздел «Избыточные и опасные возможности»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span id=".D0.92.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D1.81.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B2.D0.B0_.D0.BE.D0.B1.D1.85.D0.BE.D0.B4.D0.B0_.D0.BE.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D0.B9"></span><span class="mw-headline" id="Встроенные_средства_обхода_ограничений">Встроенные средства обхода ограничений</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=46" class="mw-editsection-visualeditor" title="Редактировать раздел «Встроенные средства обхода ограничений»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=46" title="Редактировать раздел «Встроенные средства обхода ограничений»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Язык содержит средства, позволяющие программисту нарушать заданную в конкретном случае дисциплину программирования. Например, модификатор <code>const</code> задаёт для объекта свойство неизменности состояния, но модификатор <code>mutable</code> предназначен <i>именно для</i> принудительного разрешения изменения состояния внутри константного объекта, то есть для нарушения ограничения константности. Более того, допускается динамически удалить атрибут <code>const</code> с константного объекта, превращая его в леводопустимый (L-value). Наличие в языке таких возможностей делает попытки <a href="/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F" title="Формальная верификация">формальной верификации</a> кода бессмысленными, а использование ограничений для оптимизации невозможным.
</p>
<h4><span id=".D0.9D.D0.B5.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.B8.D1.80.D1.83.D0.B5.D0.BC.D0.B0.D1.8F_.D0.BC.D0.B0.D0.BA.D1.80.D0.BE.D0.BF.D0.BE.D0.B4.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BA.D0.B0"></span><span class="mw-headline" id="Неконтролируемая_макроподстановка">Неконтролируемая макроподстановка</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=47" class="mw-editsection-visualeditor" title="Редактировать раздел «Неконтролируемая макроподстановка»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=47" title="Редактировать раздел «Неконтролируемая макроподстановка»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Средства макроподстановки Си (<code>#define</code>) являются сколь мощным, столь же опасным средством. Они сохранены в C++ несмотря на то, что для решения всех задач, для которых они были предусмотрены в Си, в C++ были предоставлены более строгие и специализированные средства&#160;— шаблоны, перегрузка функций, inline-функции, пространства имён, более развитая типизация, расширение применения модификатора const, и др. В унаследованных от Си стандартных библиотеках много потенциально опасных макросов.<sup id="cite_ref-44" class="reference"><a href="#cite_note-44">&#91;40&#93;</a></sup> Шаблонное метапрограммирование также порой совмещается с использованием макроподстановки для обеспечения т.&#160;н. «<a href="/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80" title="Синтаксический сахар">синтаксического сахара</a>».
</p>
<h4><span id=".D0.9F.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC.D1.8B_.D0.BF.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B8"></span><span class="mw-headline" id="Проблемы_перегрузки">Проблемы перегрузки</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=48" class="mw-editsection-visualeditor" title="Редактировать раздел «Проблемы перегрузки»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=48" title="Редактировать раздел «Проблемы перегрузки»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Принятые в C++ принципы перегрузки функций и операторов<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r104609042"/><span class="ts-Переход noprint" title="#Перегрузка операторов"><sup><a href="#Перегрузка_операторов">[⇨]</a></sup></span> приводят к значительному дублированию кода. Перегрузка операторов, исходно предназначенная для введения так называемого «<a href="/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80" title="Синтаксический сахар">синтаксического сахара</a>», в C++ поощряет бесконтрольное изменение поведения элементарных операций для различных типов. Это резко повышает риск ошибок, тем более что вводить новый синтаксис и изменять существующий (например, создавать новые операторы или менять приоритеты или ассоциативность) нельзя, хотя синтаксис стандартных операторов C++ адекватен семантике далеко не всех типов, которые может потребоваться ввести в программу. Отдельные проблемы создаёт возможность лёгкой перегрузки операторов <code>new/delete</code>, способной породить крайне коварные и трудновыявляемые ошибки. При этом некоторые интуитивно ожидаемые операции (подчистка динамических объектов в случае генерации исключений) в C++ не выполняются, а значительная часть перегруженных функций и операторов вызывается неявно (приведение типов, создание временных экземпляров классов и др.). В результате средства, изначально предназначенные для того, чтобы сделать программы более ясными и повысить удобство разработки и сопровождения, превращаются в ещё один источник неоправданного усложнения и снижения надёжности кода.
</p>
<h3><span id=".D0.92.D1.8B.D1.87.D0.B8.D1.81.D0.BB.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D1.8D.D1.84.D1.84.D0.B5.D0.BA.D1.82.D0.B8.D0.B2.D0.BD.D0.BE.D1.81.D1.82.D1.8C"></span><span class="mw-headline" id="Вычислительная_эффективность">Вычислительная эффективность</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=49" class="mw-editsection-visualeditor" title="Редактировать раздел «Вычислительная эффективность»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=49" title="Редактировать раздел «Вычислительная эффективность»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span id=".D0.A0.D0.B5.D0.B7.D1.83.D0.BB.D1.8C.D1.82.D0.B8.D1.80.D1.83.D1.8E.D1.89.D0.B8.D0.B9_.D0.BE.D0.B1.D1.8A.D1.91.D0.BC_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D0.BD.D0.B8.D0.BC.D0.BE.D0.B3.D0.BE_.D0.BA.D0.BE.D0.B4.D0.B0"></span><span class="mw-headline" id="Результирующий_объём_исполнимого_кода">Результирующий объём исполнимого кода</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=50" class="mw-editsection-visualeditor" title="Редактировать раздел «Результирующий объём исполнимого кода»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=50" title="Редактировать раздел «Результирующий объём исполнимого кода»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Использование шаблонов C++ представляет собой <a href="/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#Параметрический_полиморфизм" class="mw-redirect" title="Полиморфизм (программирование)">параметрический полиморфизм</a> на уровне исходного кода, но при трансляции он превращается в <a href="/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#Ситуативный_(ad_hoc)_полиморфизм" class="mw-redirect" title="Полиморфизм (программирование)">ситуативный (ad hoc) полиморфизм</a> (то есть перегрузку функций), что приводит к существенному увеличению объёма машинного кода в сравнении с языками, имеющими истинно полиморфную систему типов (потомками <a href="/wiki/ML" title="ML">ML</a>). Для снижения размера машинного кода пытаются автоматически обрабатывать исходный код до этапа раскрутки шаблонов<sup id="cite_ref-45" class="reference"><a href="#cite_note-45">&#91;41&#93;</a></sup><sup id="cite_ref-46" class="reference"><a href="#cite_note-46">&#91;42&#93;</a></sup>. Другим решением могла бы быть стандартизованная ещё в 1998 году возможность экспорта шаблонов, но она доступна далеко не во всех компиляторах, так как её трудно реализовать<sup id="cite_ref-47" class="reference"><a href="#cite_note-47">&#91;43&#93;</a></sup><sup id="cite_ref-48" class="reference"><a href="#cite_note-48">&#91;44&#93;</a></sup><sup id="cite_ref-49" class="reference"><a href="#cite_note-49">&#91;мнения 4&#93;</a></sup> и для импорта библиотек шаблонов C++ в языки с существенно отличной от C++ семантикой она всё равно была бы бесполезна. Сторонники C++ оспаривают масштабы раздувания кода как преувеличенные<sup id="cite_ref-50" class="reference"><a href="#cite_note-50">&#91;45&#93;</a></sup>, игнорируя даже тот факт, что в Си параметрический полиморфизм транслируется непосредственно, то есть без дублирования тел функций вообще. При этом сторонники C++ считают, что параметрический полиморфизм в Си опасен&#160;— то есть более опасен, чем переход от Си к C++ (противники C++ утверждают обратное&#160;— см. выше).
</p>
<h4><span id=".D0.9F.D0.BE.D1.82.D0.B5.D0.BD.D1.86.D0.B8.D0.B0.D0.BB_.D0.BE.D0.BF.D1.82.D0.B8.D0.BC.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8"></span><span class="mw-headline" id="Потенциал_оптимизации">Потенциал оптимизации</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=51" class="mw-editsection-visualeditor" title="Редактировать раздел «Потенциал оптимизации»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=51" title="Редактировать раздел «Потенциал оптимизации»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Из-за слабой системы типов и изобилия <a href="/wiki/%D0%9F%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Побочный эффект (программирование)">побочных эффектов</a> становится крайне затруднительным эквивалентное преобразование программ, а значит и встраивание в компилятор многих оптимизирующих алгоритмов, таких как автоматическое <a href="/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC" title="Распараллеливание программ">распараллеливание программ</a>, <a href="/wiki/%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%89%D0%B8%D1%85_%D0%BF%D0%BE%D0%B4%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9" title="Удаление общих подвыражений">удаление общих подвыражений</a>, λ-подъём, вызовы процедур с передачей <a href="/wiki/%D0%9F%D1%80%D0%BE%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)" title="Продолжение (информатика)">продолжений</a>, <a href="/wiki/%D0%A1%D1%83%D0%BF%D0%B5%D1%80%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F" title="Суперкомпиляция">суперкомпиляция</a> и др. В результате реальная эффективность программ на C++ ограничивается имеющейся квалификацией программистов и вложенными в конкретный проект усилиями, и «небрежная» реализация может существенно уступать по эффективности «небрежным» реализациям на языках более высокого уровня, что подтверждается сравнительными испытаниями языков<sup id="cite_ref-raytracer_51-0" class="reference"><a href="#cite_note-raytracer-51">&#91;46&#93;</a></sup>. Это является существенным препятствием против применения C++ в индустрии <a href="/wiki/Data_mining" title="Data mining">data mining</a>.
</p>
<h4><span id=".D0.AD.D1.84.D1.84.D0.B5.D0.BA.D1.82.D0.B8.D0.B2.D0.BD.D0.BE.D0.B5_.D1.83.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D1.8C.D1.8E"></span><span class="mw-headline" id="Эффективное_управление_памятью">Эффективное управление памятью</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=52" class="mw-editsection-visualeditor" title="Редактировать раздел «Эффективное управление памятью»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=52" title="Редактировать раздел «Эффективное управление памятью»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Обязанность по эффективному управлению памятью ложится на плечи разработчика и зависит от навыков разработчика. Для автоматического управления памятью в C++ традиционно используются т. н. «умные указатели», ручное же управление памятью снижает эффективность самих программистов (см. раздел <a href="#Результативность">Результативность</a>). Многочисленные реализации <a href="/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0" title="Сборка мусора">сборки мусора</a>, таких как статический <a href="/w/index.php?title=%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%80%D0%B5%D0%B3%D0%B8%D0%BE%D0%BD%D0%BE%D0%B2&amp;action=edit&amp;redlink=1" class="new" title="Вывод регионов (страница отсутствует)">вывод регионов</a> (<a href="/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA" title="Английский язык">англ.</a>&#160;<span style="font-style:italic"><a href="https://en.wikipedia.org/wiki/region-based_memory_management" class="extiw" title="en:region-based memory management"><span title="Версия статьи «Вывод регионов» на английском языке">region-based memory management</span></a></span>) не применимы для C++ программ (точнее, это требует реализации поверх языка C++ интерпретатора нового языка, сильно отличающегося от C++ как большинством объективных свойств, так и общей идеологией) по причине необходимости прямого доступа к <a href="/wiki/AST" class="mw-redirect" title="AST">AST</a>.
</p>
<h3><span id=".D0.A0.D0.B5.D0.B7.D1.83.D0.BB.D1.8C.D1.82.D0.B0.D1.82.D0.B8.D0.B2.D0.BD.D0.BE.D1.81.D1.82.D1.8C"></span><span class="mw-headline" id="Результативность">Результативность</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=53" class="mw-editsection-visualeditor" title="Редактировать раздел «Результативность»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=53" title="Редактировать раздел «Результативность»">править код</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Соотнесение факторов результативности с затратами на разработку, а также общая культивируемая в сообществе программистов дисциплина и культура программирования важны для заказчиков, выбирающих язык (и, соответственно, предпочитающих этот язык разработчиков) для реализации задуманных ими проектов, а также для людей, начинающих изучать программирование, особенно с намерением программировать для собственных нужд.
</p>
<h4><span id=".D0.9A.D0.B0.D1.87.D0.B5.D1.81.D1.82.D0.B2.D0.BE_.D0.B8_.D0.BA.D1.83.D0.BB.D1.8C.D1.82.D1.83.D1.80.D0.B0_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"></span><span class="mw-headline" id="Качество_и_культура_программирования">Качество и культура программирования</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=54" class="mw-editsection-visualeditor" title="Редактировать раздел «Качество и культура программирования»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=54" title="Редактировать раздел «Качество и культура программирования»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Принцип C++ «<i>не навязывать „хороший“ стиль программирования</i>» противоречит промышленному подходу к программированию, в котором ведущую роль играют <a href="/wiki/%D0%9A%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F" title="Качество программного обеспечения">качество программного обеспечения</a> и возможность сопровождения кода не только автором, и для которого предпочтительны языки, сводящие к минимуму влияние <a href="/wiki/%D0%A7%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80" title="Человеческий фактор">человеческого фактора</a>, то есть как раз «<i>навязывающие „хороший“ стиль программирования</i>», хотя такие языки и могут иметь более высокий порог вхождения.
</p><p>Существует мнение, что предпочтение использования C++ (при возможности выбора альтернативных языков) отрицательно характеризует профессиональные качества программиста. В частности, <a href="/wiki/%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81,_%D0%9B%D0%B8%D0%BD%D1%83%D1%81" title="Торвальдс, Линус">Линус Торвальдс</a> говорит, что использует положительное мнение кандидатов о C++ в качестве критерия отсева<sup id="cite_ref-torvalds_31-1" class="reference"><a href="#cite_note-torvalds-31">&#91;мнения 3&#93;</a></sup>:
<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r106630606"/>
</p>
<blockquote class="ts-Начало_цитаты-quote"><p>
C++&#160;— кошмарный язык. Его делает ещё более кошмарным тот факт, что множество недостаточно грамотных программистов используют его… Откровенно говоря, даже если нет <b>никаких</b> причин для выбора Си, кроме того чтобы держать C++-программистов подальше&#160;— то одно это уже будет достаточно веским основанием для использования Си.<br />…Я пришёл к выводу, что <b>действительно</b> предпочту выгнать любого, кто предпочтёт вести разработку проекта на C++, нежели на Си, чтобы этот человек не загубил проект, в который я вовлечён.<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r104610272"/></p><div class="ts-Конец_цитаты-source">— <cite><a href="/wiki/%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81,_%D0%9B%D0%B8%D0%BD%D1%83%D1%81" title="Торвальдс, Линус">Линус Торвальдс</a>,<sup id="cite_ref-autogenerated1_34-3" class="reference"><a href="#cite_note-autogenerated1-34">&#91;31&#93;</a></sup></cite></div></blockquote>
<h4><span id=".D0.98.D1.81.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D1.81.D0.BF.D1.80.D0.B0.D0.B2.D0.BD.D0.BE.D0.B3.D0.BE"></span><span class="mw-headline" id="Исправление_исправного">Исправление исправного</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=55" class="mw-editsection-visualeditor" title="Редактировать раздел «Исправление исправного»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=55" title="Редактировать раздел «Исправление исправного»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Непрерывная эволюция языка побуждает (а порой вынуждает) программистов раз за разом изменять уже отлаженный код&#160;— это не только удорожает разработку, но и несёт риск внедрения в отлаженный код новых ошибок. В частности, хотя изначально обратная совместимость с Си была одним из базовых принципов C++, с 1999 года Си перестал быть подмножеством C++, так что отлаженный код на Си уже не может использоваться в проекте на C++ без изменений.
</p>
<h4><span id=".D0.A1.D0.BB.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D1.8C_.D1.80.D0.B0.D0.B4.D0.B8_.D1.81.D0.B0.D0.BC.D0.BE.D0.B9_.D1.81.D0.BB.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8"></span><span class="mw-headline" id="Сложность_ради_самой_сложности">Сложность ради самой сложности</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=56" class="mw-editsection-visualeditor" title="Редактировать раздел «Сложность ради самой сложности»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=56" title="Редактировать раздел «Сложность ради самой сложности»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>C++ определяется его апологетами как «мощнейший» <i>именно потому</i>, что он изобилует опасными взаимно-противоречивыми возможностями. По мнению <a href="/wiki/%D0%A0%D0%B5%D0%B9%D0%BC%D0%BE%D0%BD%D0%B4,_%D0%AD%D1%80%D0%B8%D0%BA" class="mw-redirect" title="Реймонд, Эрик">Эрика Реймонда</a>,&#160;это делает язык сам по себе почвой для личного самоутверждения программистов, превращения процесса разработки в самоцель:<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r106630606"/>
</p>
<blockquote class="ts-Начало_цитаты-quote"><p>
Программисты&#160;— это зачастую яркие люди, которые гордятся … своей способностью справляться со сложностями и ловко обращаться с абстракциями. Часто они состязаются друг с другом, пытаясь выяснить, кто может создать «самые замысловатые и красивые сложности». … соперники полагают, что должны соревноваться с чужими «украшательствами» путём добавления собственных. Довольно скоро «массивная опухоль» становится индустриальным стандартом, и все используют большие, переполненные ошибками программы, которые не способны удовлетворить даже их создателей.<br />…<br />… такой подход может обернуться неприятностями, если программисты реализуют простые вещи сложными способами, просто потому что им известны эти способы и они умеют ими пользоваться.<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r104610272"/></p><div class="ts-Конец_цитаты-source">— <cite><a href="/wiki/%D0%A0%D0%B5%D0%B9%D0%BC%D0%BE%D0%BD%D0%B4,_%D0%AD%D1%80%D0%B8%D0%BA" class="mw-redirect" title="Реймонд, Эрик">Эрик Реймонд</a> в <sup id="cite_ref-52" class="reference"><a href="#cite_note-52">&#91;47&#93;</a></sup></cite></div></blockquote>
<h4><span id=".D0.A1.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D0.B6"></span><span class="mw-headline" id="Саботаж">Саботаж</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=57" class="mw-editsection-visualeditor" title="Редактировать раздел «Саботаж»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=57" title="Редактировать раздел «Саботаж»">править код</a><span class="mw-editsection-bracket">]</span></span></h4><p>
Отмечены случаи, когда нерадивые программисты, пользуясь сильной контекстной зависимостью C++ и отсутствием возможности отслеживания макроопределений компилятором тормозили разработку проекта, написав одну-две лишних, корректных с точки зрения компилятора, строки кода, но внедрив за их счёт труднообнаружимую спонтанно проявляющуюся ошибку. Например:</p><div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define if(a) if(rand())</span>
</pre></div><p><br /></p><div class="mw-highlight mw-highlight-lang-cpp mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#define j i</span>
</pre></div><p>В <a href="/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Чистота языка программирования">языках с доказанной корректностью</a>, даже с развитыми макро-средствами, нанести урон подобным образом невозможно.
</p><h4><span id=".D0.9D.D0.B5.D0.BD.D0.B0.D0.B4.D1.91.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D1.8C_.D0.BF.D1.80.D0.BE.D0.B4.D1.83.D0.BA.D1.82.D0.B0"></span><span class="mw-headline" id="Ненадёжность_продукта">Ненадёжность продукта</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=58" class="mw-editsection-visualeditor" title="Редактировать раздел «Ненадёжность продукта»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=58" title="Редактировать раздел «Ненадёжность продукта»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Неоправданное обилие побочных эффектов в сочетании с отсутствием контроля со стороны системы времени исполнения языка и слабой системой типов делает программы на C++ подверженными непредсказуемым фатальным сбоям (общеизвестные падения с сообщениями типа «Access violation», «Pure virtual function call» или «Программа выполнила недопустимую операцию и будет закрыта»), что исключает применение C++ при высоких требованиях к отказоустойчивости. Кроме того, это увеличивает длительность самого процесса разработки<sup id="cite_ref-raytracer_51-1" class="reference"><a href="#cite_note-raytracer-51">&#91;46&#93;</a></sup>.
</p>
<h4><span id=".D0.9C.D0.B5.D0.BD.D0.B5.D0.B4.D0.B6.D0.BC.D0.B5.D0.BD.D1.82_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D0.BE.D0.B2"></span><span class="mw-headline" id="Менеджмент_проектов">Менеджмент проектов</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=59" class="mw-editsection-visualeditor" title="Редактировать раздел «Менеджмент проектов»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=59" title="Редактировать раздел «Менеджмент проектов»">править код</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Перечисленные выше факторы делают сложность менеджмента проектов на C++ одной из самых высоких в индустрии разработки ПО.<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r106630606"/>
</p>
<blockquote class="ts-Начало_цитаты-quote"><p>
Джеймс Коггинс, в течение четырёх лет ведущий колонку в <i>The C++ Report</i>, дает такое объяснение:<br />&#160;— Проблема в том, что программисты, работающие в ООП, экспериментировали с кровосмесительными приложениями и были нацелены на низкий уровень абстракции. Например, они строили такие классы как «связанный список», вместо «интерфейс пользователя», или «луч радиации», или «модель из конечных элементов». К несчастью, строгая проверка типов, которая помогает программистам C++ избегать ошибок, одновременно затрудняет построение больших объектов из маленьких.<link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r104610272"/></p><div class="ts-Конец_цитаты-source">— <cite><a href="/wiki/%D0%91%D1%80%D1%83%D0%BA%D1%81,_%D0%A4%D1%80%D0%B5%D0%B4%D0%B5%D1%80%D0%B8%D0%BA" title="Брукс, Фредерик">Ф. Брукс</a>, <a href="/wiki/%D0%9C%D0%B8%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%87%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA%D0%BE-%D0%BC%D0%B5%D1%81%D1%8F%D1%86" title="Мифический человеко-месяц">Мифический человеко-месяц</a></cite></div></blockquote>
<h2><span id=".D0.92.D0.BB.D0.B8.D1.8F.D0.BD.D0.B8.D0.B5_.D0.B8_.D0.B0.D0.BB.D1.8C.D1.82.D0.B5.D1.80.D0.BD.D0.B0.D1.82.D0.B8.D0.B2.D1.8B"></span><span class="mw-headline" id="Влияние_и_альтернативы">Влияние и альтернативы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=C%2B%2B&amp;veaction=edit&amp;section=60" class="mw-editsection-visualeditor" title="Редактировать раздел «Влияние и альтернативы»">править</a><span class="mw-editsection-divider"> | </span><a href="/w/index.php?title=C%2B%2B&amp;action=edit&amp;section=60" title="Редактировать раздел «Влияние и альтернативы»">править код</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Единственным прямым потомком C++ является <a href="/wiki/D_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="D (язык программирования)">язык D</a>, задуманный как переработка C++ для устранения наиболее очевидных его проблем. Авторы отказались от совместимости с Си, сохранив синтаксис и многие базовые принципы C++ и введя в язык возможности, характерные для новых языков. В D нет препроцессора, заголовочных файлов, множественного наследования, но есть система модулей, интерфейсы, ассоциативные массивы, поддержка <a href="/wiki/Unicode" class="mw-redirect" title="Unicode">unicode</a> в строках, <a href="/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0" title="Сборка мусора">сборка мусора</a> (при сохранении возможности ручного управления памятью) встроенная многопоточность, <a href="/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" title="Вывод типов">вывод типов</a>, явное объявление чистых функций и неизменяемых значений. Использование D весьма ограничено, считать его реальным конкурентом C++ нельзя.
</p><p>Старейшим конкурентом C++ в задачах низкого уровня является <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, также построенный по принципу объединения <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">Си</a> с объектной моделью, только объектная модель унаследована от <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>. Objective-C, как и его потомок <a href="/wiki/Swift_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Swift (язык программирования)">Swift</a>, широко используется для разработки ПО под macOS и iOS.
</p><p>Одной из первых альтернатив C++ в прикладном программировании стал язык <a href="/wiki/Java_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" class="mw-redirect" title="Java (язык программирования)">Java</a>. Его часто ошибочно считают прямым потомком C++; в действительности семантика Java унаследована от языка <a href="/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B0-2" title="Модула-2">Модула-2</a>, и основы семантики C++ в Java не прослеживаются. Учитывая это, а также генеалогию языков (Модула-2 является потомком <a href="/wiki/%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0" title="Симула">Симулы</a>, как и C++, но им не является Си), Java правильнее называть «<i>троюродным племянником</i>» C++, нежели «<i>наследником</i>». То же можно сказать о языке <a href="/wiki/C_Sharp" title="C Sharp">C#</a>.
</p><p>Попыткой совмещения безопасности и скорости разработки, характерных для Java и C#, с возможностями C++ явился диалект <a href="/wiki/Managed_C%2B%2B" title="Managed C++">Managed C++</a> (впоследствии - <a href="/wiki/C%2B%2B/CLI" title="C++/CLI">C++/CLI</a>). Он разработан Microsoft в основном для переноса существующих проектов на C++ под платформу Microsoft.NET. Программы выполняются под управлением <a href="/wiki/Common_Language_Runtime" title="Common Language Runtime">CLR</a> и могут использовать весь массив библиотек .NET, но при этом накладывается ряд ограничений на использование возможностей C++, что фактически сводит C++ к C#. Данный диалект не получил широкого признания.
</p><p>Альтернативный путь развития языка Си&#160;— совмещение его не с объектно-ориентированным, а с <a href="/wiki/%D0%90%D0%BF%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Аппликативное программирование">аппликативным программированием</a>, то есть улучшение абстракции, строгости и модульности низкоуровневых программ посредством обеспечения <a href="/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" title="Чистота языка программирования">предсказуемости поведения</a> и <a href="/wiki/%D0%A1%D1%81%D1%8B%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B7%D1%80%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C" title="Ссылочная прозрачность">ссылочной прозрачности</a>. Примерами работ в этом русле служат языки <a href="/wiki/BitC" title="BitC">BitC</a>, <a href="/wiki/Cyclone_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Cyclone (язык программирования)">Cyclone</a> и <a href="/wiki/Limbo" title="Limbo">Limbo</a>. Хотя есть и успешные попытки применения ФП в задачах реального времени без интеграции со средствами Си<sup id="cite_ref-53" class="reference"><a href="#cite_note-53">&#91;48&#93;</a></sup><sup id="cite_ref-54" class="reference"><a href="#cite_note-54">&#91;49&#93;</a></sup><sup id="cite_ref-55" class="reference"><a href="#cite_note-55">&#91;50&#93;</a></sup>, всё же на данный момент (2013&#160;г.) в низкоуровневой разработке применение в той или иной мере средств Си имеет лучшее соотношение трудоёмкости с результативностью. Много усилий было приложено разработчиками <a href="/wiki/Python_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" class="mw-redirect" title="Python (язык программирования)">Python</a> и <a href="/wiki/Lua" title="Lua">Lua</a> для обеспечения использования этих языков программистами на C++, так что из всех языков, достаточно тесно связанных с ФП, именно они чаще всего отмечаются в совместном использовании с C++ в одном проекте. Наиболее значимыми точками соприкосновения C++ с ФП можно считать привязки разработанных на C++ библиотек <a href="/wiki/WxWidgets" title="WxWidgets">wxWidgets</a> и <a href="/wiki/Qt" title="Qt">Qt</a> с характерной для C++ идеологией к языкам <a href="/wiki/Lisp" class="mw-redirect" title="Lisp">Lisp</a>, <a href="/wiki/Haskell" title="Haskell">Haskell</a> и <a href="/wiki/Python_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" class="mw-redirect" title="Python (язык программирования)">Python</a> (в большинстве случаев привязки к функциональным языкам делают для библиотек, написанных на Си или на других функциональных языках).
</p><p>Ещё одним языком, рассматриваемым как конкурент C++, стал <a href="/wiki/Nemerle" title="Nemerle">Nemerle</a>, являющийся результатом попытки совместить <a href="/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%A5%D0%B8%D0%BD%D0%B4%D0%BB%D0%B8-%D0%9C%D0%B8%D0%BB%D0%BD%D0%B5%D1%80%D0%B0" class="mw-redirect" title="Модель типизации Хиндли-Милнера">модель типизации Хиндли-Милнера</a> и макро-подмножество <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a> с языком C#.<sup id="cite_ref-56" class="reference"><a href="#cite_note-56">&#91;51&#93;</a></sup>. В том же русле находится созданный Microsoft язык <a href="/wiki/F_Sharp" title="F Sharp">F#</a>&#160;— диалект <a href="/wiki/ML" title="ML">ML</a>, адаптированный для среды .NET.
</p><p>Попыткой создать промышленную замену C/C++ стал разработанный в корпорации Google в 2009 году язык программирования <a href="/wiki/Go" title="Go">Go</a>. Авторы языка прямо указывают, что мотивом для его создания были недостатки процесса разработки, вызванные особенностями языков <a href="/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Си (язык программирования)">Си</a> и <a class="mw-selflink selflink">C++</a><sup id="cite_ref-designGo_57-0" class="reference"><a href="#cite_note-designGo-57">&#91;52&#93;</a></sup>. Go&#160;— компактный, несложный по структуре императивный язык с Си-подобным синтаксисом, без препроцессора, со статической типизацией, строгим контролем типов, системой пакетов, автоматическим управлением памятью, некоторыми функциональными чертами, экономно построенной ООП-подсистемой без поддержки наследования реализации, но с интерфейсами и <a href="/wiki/%D0%A3%D1%82%D0%B8%D0%BD%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" title="Утиная типизация">утиной типизацией</a>, встроенной многопоточностью, основанной на сопрограммах и каналах (a-la <a href="/wiki/Occam" title="Occam">Occam</a>). Язык позиционируется как альтернатива C++, то есть, в первую очередь, средство групповой разработки высокоэффективных вычислительных систем большой сложности, в том числе распределённых, допускающее, при необходимости, низкоуровневое программирование.
</p><p>В одной экологической нише с C/C++ находится разработанный в 2010 году и поддерживаемый корпорацией <a href="/wiki/Mozilla_Corporation" title="Mozilla Corporation">Mozilla</a> язык <a href="/wiki/Rust_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" title="Rust (язык программирования)">Rust</a>, ориентированный на безопасное <a href="/wiki/%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E" class="mw-redirect" title="Управление памятью">управление памятью</a> без использования <a href="/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0" title="Сборка мусора">сборщика мусора</a>. В частности о планах частичной замены C/C++ на Rust объявила в 2019 компания <a href="/wiki/Microsoft" title="Microsoft">Microsoft</a><sup id="cite_ref-58" class="reference"><a href="#cite_note-58">&#91;53&#93;</a></sup>.
</p>
              
                <!-- *************************************************************** -->
            </div>
            
            </div>
                
            <!-- ============================================================== -->
            <!-- End Container fluid  -->
            <!-- ============================================================== -->
            <!-- ============================================================== -->
            <!-- footer -->
            <!-- ============================================================== -->
            <footer class="footer text-center text-muted">
            <small class="copyright">Амирджон Раджабов <i class="fa fa-heart"></i> 2020 <a href="#">OSCODE.RU</a> © Все права защищены</small>
            </footer>
            <!-- ============================================================== -->
            <!-- End footer -->
            <!-- ============================================================== -->
        </div>
        <!-- ============================================================== -->
        <!-- End Page wrapper  -->
        <!-- ============================================================== -->
    </div>
    <!-- ============================================================== -->
    <!-- End Wrapper -->
    <!-- ============================================================== -->
    <!-- End Wrapper -->
    <!-- ============================================================== -->
    <!-- All Jquery -->
    <!-- ============================================================== -->
    <script src="../../assets/libs/jquery/dist/jquery.min.js"></script>
    <script src="../../assets/libs/popper.js/dist/umd/popper.min.js"></script>
    <script src="../../assets/libs/bootstrap/dist/js/bootstrap.min.js"></script>
    <!-- apps -->
    <!-- apps -->
    <script src="../../dist/js/app-style-switcher.js"></script>
    <script src="../../dist/js/feather.min.js"></script>
    <script src="../../assets/libs/perfect-scrollbar/dist/perfect-scrollbar.jquery.min.js"></script>
    <script src="../../dist/js/sidebarmenu.js"></script>
    <!--Custom JavaScript -->
    <script src="../../dist/js/custom.min.js"></script>
    <!--This page JavaScript -->
    <script src="../../assets/extra-libs/c3/d3.min.js"></script>
    <script src="../../assets/extra-libs/c3/c3.min.js"></script>
    <script src="../../assets/libs/chartist/dist/chartist.min.js"></script>
    <script src="../../assets/libs/chartist-plugin-tooltips/dist/chartist-plugin-tooltip.min.js"></script>
    <script src="../../assets/extra-libs/jvector/jquery-jvectormap-2.0.2.min.js"></script>
    <script src="../../assets/extra-libs/jvector/jquery-jvectormap-world-mill-en.js"></script>
    <script src="../../dist/js/pages/dashboards/dashboard1.min.js"></script>
</body>

</html>